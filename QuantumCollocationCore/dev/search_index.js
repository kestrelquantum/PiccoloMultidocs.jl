var documenterSearchIndex = {"docs":
[{"location":"generated/explanation/","page":"Explanation","title":"Explanation","text":"EditURL = \"../../literate/explanation.jl\"","category":"page"},{"location":"generated/explanation/#Quickstart-Guide","page":"Explanation","title":"Quickstart Guide","text":"","category":"section"},{"location":"generated/explanation/#Installation","page":"Explanation","title":"Installation","text":"","category":"section"},{"location":"generated/explanation/","page":"Explanation","title":"Explanation","text":"using QuantumCollocationCore","category":"page"},{"location":"generated/explanation/#This-package-also-provides-various-objects-and-bindings-used-in-Quantum-Optimal-Control-problems.","page":"Explanation","title":"This package also provides various objects and bindings used in Quantum Optimal Control problems.","text":"","category":"section"},{"location":"generated/explanation/","page":"Explanation","title":"Explanation","text":"This means various common constraints, integrators, objectives, and losses. This package also provides interfaces for the commonly needed dynamics, and evaluator objects to provide to the solver - which for now is Ipopt.","category":"page"},{"location":"generated/explanation/","page":"Explanation","title":"Explanation","text":"","category":"page"},{"location":"generated/explanation/","page":"Explanation","title":"Explanation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/#Library","page":"Lib","title":"Library","text":"","category":"section"},{"location":"lib/","page":"Lib","title":"Lib","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/#Constraints","page":"Lib","title":"Constraints","text":"","category":"section"},{"location":"lib/","page":"Lib","title":"Lib","text":"Modules = [QuantumCollocationCore.Constraints]","category":"page"},{"location":"lib/#QuantumCollocationCore.Constraints.EqualityConstraint","page":"Lib","title":"QuantumCollocationCore.Constraints.EqualityConstraint","text":"struct EqualityConstraint\n\nRepresents a linear equality constraint.\n\nFields\n\nts::AbstractArray{Int}: the time steps at which the constraint is applied\njs::AbstractArray{Int}: the components of the trajectory at which the constraint is applied\nvals::Vector{R}: the values of the constraint\nvardim::Int: the dimension of a single time step of the trajectory\nlabel::String: a label for the constraint\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocationCore.Constraints.NonlinearEqualityConstraint","page":"Lib","title":"QuantumCollocationCore.Constraints.NonlinearEqualityConstraint","text":"struct NonlinearEqualityConstraint\n\nRepresents a nonlinear equality constraint.\n\nFields\n\ng::Function: the constraint function\n∂g::Function: the Jacobian of the constraint function\n∂g_structure::Vector{Tuple{Int, Int}}: the structure of the Jacobian  i.e. all non-zero entries\nμ∂²g::Function: the Hessian of the constraint function\nμ∂²g_structure::Vector{Tuple{Int, Int}}: the structure of the Hessian\ndim::Int: the dimension of the constraint function\nparams::Dict{Symbol, Any}: a dictionary of parameters\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocationCore.Constraints.NonlinearInequalityConstraint","page":"Lib","title":"QuantumCollocationCore.Constraints.NonlinearInequalityConstraint","text":"struct NonlinearInequalityConstraint\n\nRepresents a nonlinear inequality constraint.\n\nFields\n\ng::Function: the constraint function\n∂g::Function: the Jacobian of the constraint function\n∂g_structure::Vector{Tuple{Int, Int}}: the structure of the Jacobian  i.e. all non-zero entries\nμ∂²g::Function: the Hessian of the constraint function\nμ∂²g_structure::Vector{Tuple{Int, Int}}: the structure of the Hessian\ndim::Int: the dimension of the constraint function\nparams::Dict{Symbol, Any}: a dictionary of parameters containing additional  information about the constraint\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocationCore.Constraints.ComplexModulusContraint-Tuple{Symbol, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Lib","title":"QuantumCollocationCore.Constraints.ComplexModulusContraint","text":"ComplexModulusContraint(symb::Symbol, R::Float64, traj::NamedTrajectory)\n\nReturns a ComplexModulusContraint for the complex control NamedTrajector symbol where R is the maximum allowed complex modulus.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Constraints.ComplexModulusContraint-Tuple{}","page":"Lib","title":"QuantumCollocationCore.Constraints.ComplexModulusContraint","text":"ComplexModulusContraint(<keyword arguments>)\n\nReturns a NonlinearInequalityConstraint on the complex modulus of a complex control\n\nTODO: Changed zdim -> dim. Constraint should be tested for global params.\n\nArguments\n\nR::Union{Float64,Nothing}=nothing: the maximum allowed complex modulus\ncomps::Union{AbstractVector{Int},Nothing}=nothing: the components of the complex control,  both the real and imaginary parts\ntimes::Union{AbstractVector{Int},Nothing}=nothing: the times at which the constraint is applied\ndim::Union{Int,Nothing}=nothing: the dimension of a single time step of the trajectory\nT::Union{Int,Nothing}=nothing: the number of time steps\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Constraints.FinalFidelityConstraint-Tuple{}","page":"Lib","title":"QuantumCollocationCore.Constraints.FinalFidelityConstraint","text":"FinalFidelityConstraint(<keyword arguments>)\n\nReturns a NonlinearInequalityConstraint representing a constraint on the minimum allowed fidelity.\n\nArguments\n\nfidelity_function::Union{Function,Nothing}=nothing: the fidelity function\nvalue::Union{Float64,Nothing}=nothing: the minimum fidelity value allowed  by the constraint\ncomps::Union{AbstractVector{Int},Nothing}=nothing: the components of the  state to which the fidelity function is applied\ngoal::Union{AbstractVector{Float64},Nothing}=nothing: the goal state\nstatedim::Union{Int,Nothing}=nothing: the dimension of the state\nzdim::Union{Int,Nothing}=nothing: the dimension of a single time step of the trajectory\nT::Union{Int,Nothing}=nothing: the number of time steps\nsubspace::Union{AbstractVector{<:Integer}, Nothing}=nothing: the subspace indices of the fidelity\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Constraints.FinalQuantumStateFidelityConstraint-Tuple{Symbol, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Lib","title":"QuantumCollocationCore.Constraints.FinalQuantumStateFidelityConstraint","text":"FinalQuantumStateFidelityConstraint(statesymb::Symbol, val::Float64, traj::NamedTrajectory)\n\nReturns a FinalFidelityConstraint for the unitary fidelity function where statesymb is the NamedTrajectory symbol representing the unitary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Constraints.FinalUnitaryFidelityConstraint-Tuple{Symbol, Float64, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Lib","title":"QuantumCollocationCore.Constraints.FinalUnitaryFidelityConstraint","text":"FinalUnitaryFidelityConstraint(statesymb::Symbol, val::Float64, traj::NamedTrajectory)\n\nReturns a FinalFidelityConstraint for the unitary fidelity function where statesymb is the NamedTrajectory symbol representing the unitary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Constraints.FinalUnitaryFreePhaseFidelityConstraint-Tuple{}","page":"Lib","title":"QuantumCollocationCore.Constraints.FinalUnitaryFreePhaseFidelityConstraint","text":"FinalUnitaryFreePhaseFidelityConstraint\n\nReturns a NonlinearInequalityConstraint representing a constraint on the minimum allowed fidelity for a free phase unitary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Constraints.constrain!-Tuple{Ipopt.Optimizer, Vector{MathOptInterface.VariableIndex}, Vector{LinearConstraint}, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Lib","title":"QuantumCollocationCore.Constraints.constrain!","text":"constrain!(opt::Ipopt.Optimizer, vars::Vector{MOI.VariableIndex}, cons::Vector{LinearConstraint}, traj::NamedTrajectory; verbose=false)\n\nSupplies a set of LinearConstraints to  IPOPT using MathOptInterface\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Constraints.trajectory_constraints-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Lib","title":"QuantumCollocationCore.Constraints.trajectory_constraints","text":"trajectory_constraints(traj::NamedTrajectory)\n\nImplements the initial and final value constraints and bounds constraints on the controls and states as specified by traj.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Integrators","page":"Lib","title":"Integrators","text":"","category":"section"},{"location":"lib/","page":"Lib","title":"Lib","text":"Modules = [QuantumCollocationCore.Integrators]","category":"page"},{"location":"lib/#QuantumCollocationCore.Integrators.UnitaryPadeIntegrator","page":"Lib","title":"QuantumCollocationCore.Integrators.UnitaryPadeIntegrator","text":"\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocationCore.Integrators.UnitaryPadeIntegrator-Tuple{Symbol, Union{Symbol, Tuple{Vararg{Symbol}}}, PiccoloQuantumObjects.QuantumSystems.QuantumSystem, NamedTrajectories.StructNamedTrajectory.NamedTrajectory}","page":"Lib","title":"QuantumCollocationCore.Integrators.UnitaryPadeIntegrator","text":"UnitaryPadeIntegrator(\n    unitary_name::Symbol,\n    drive_name::Union{Symbol,Tuple{Vararg{Symbol}}},\n    G::Function,\n    ∂G::Function,\n    traj::NamedTrajectory;\n    order::Int=4,\n    calculate_pade_operators_structure::Bool=true,\n    autodiff::Bool=false\n)\n\nConstruct a UnitaryPadeIntegrator which computes\n\ntextisovecqty(B^(n)(a_t) U_t+1 - F^(n)(a_t) U_t)\n\nwhere U_t is the unitary at time t, a_t is the control at time t, and B^{(n)}(a_t) and F^{(n)}(a_t) are the nth order Pade operators of the exponential of the drift operator G(a_t).\n\nArguments\n\nunitary_name::Symbol: the name of the unitary in the trajectory\ndrive_name::Union{Symbol,Tuple{Vararg{Symbol}}}: the name of the drive(s) in the trajectory\nG::Function: a function which takes the control vector a_t and returns the drive G(a_t), G(a_t) = textiso(-i H(a_t))\n∂G::Function: a function which takes the control vector a_t and returns a vector of matrices qty(ldots pdvGa^j_t ldots)\ntraj::NamedTrajectory: the trajectory\n\nKeyword Arguments\n\norder::Int=4: the order of the Pade approximation. Must be in [4, 6, 8, 10, 12, 14, 16, 18, 20].\n\n\n\n\n\n","category":"method"},{"location":"lib/#Losses","page":"Lib","title":"Losses","text":"","category":"section"},{"location":"lib/","page":"Lib","title":"Lib","text":"Modules = [QuantumCollocationCore.Losses]","category":"page"},{"location":"lib/#QuantumCollocationCore.Losses.iso_fidelity-Tuple{AbstractVector{<:Real}, AbstractVector{<:Real}}","page":"Lib","title":"QuantumCollocationCore.Losses.iso_fidelity","text":"iso_fidelity(ψ̃, ψ̃_goal)\n\nCalculate the fidelity between two quantum states ψ and ψ_goal.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Losses.iso_infidelity","page":"Lib","title":"QuantumCollocationCore.Losses.iso_infidelity","text":"iso_infidelity(ψ̃, ψ̃goal)\n\nReturns the iso_infidelity between two quantum statevectors specified in the mathbbC^n to mathbbR^2n isomorphism space.\n\n\n\n\n\n","category":"function"},{"location":"lib/#QuantumCollocationCore.Losses.iso_vec_unitary_fidelity-Tuple{AbstractVector, AbstractVector}","page":"Lib","title":"QuantumCollocationCore.Losses.iso_vec_unitary_fidelity","text":"iso_vec_unitary_fidelity(Ũ⃗::AbstractVector, Ũ⃗_goal::AbstractVector)\n\nReturns the fidelity between the isomorphic unitary vector vecwidetildeU sim U in SU(n) and the isomorphic goal unitary vector vecwidetildeU_textgoal.\n\nbeginaligned\nmathcalF(vecwidetildeU vecwidetildeU_textgoal) = frac1n abstr qty(U_textgoal^dagger U) \n= frac1n sqrtT_R^2 + T_I^2\nendaligned\n\nwhere T_R = langle vecwidetildeU_textgoal R vecwidetildeU_R rangle + langle vecwidetildeU_textgoal I vecwidetildeU_I rangle and T_I = langle vecwidetildeU_textgoal R vecwidetildeU_I rangle - langle vecwidetildeU_textgoal I vecwidetildeU_R rangle.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Losses.unitary_fidelity-Tuple{AbstractMatrix, AbstractMatrix}","page":"Lib","title":"QuantumCollocationCore.Losses.unitary_fidelity","text":"unitary_fidelity(U::Matrix, U_goal::Matrix; kwargs...)\nunitary_fidelity(Ũ⃗::AbstractVector, Ũ⃗_goal::AbstractVector; kwargs...)\n\nCalculate the fidelity between two unitary operators U and U_goal.\n\nmathcalF(U U_textgoal) = frac1n abstr qty(U_textgoal^dagger U)\n\nwhere n is the dimension of the unitary operators.\n\nKeyword Arguments\n\nsubspace::AbstractVector{Int}: The subspace to calculate the fidelity over.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Objectives","page":"Lib","title":"Objectives","text":"","category":"section"},{"location":"lib/","page":"Lib","title":"Lib","text":"Modules = [QuantumCollocationCore.Objectives]","category":"page"},{"location":"lib/#QuantumCollocationCore.Objectives.Objective","page":"Lib","title":"QuantumCollocationCore.Objectives.Objective","text":"Objective\n\nA structure for defining objective functions.\n\nThe terms field contains all the arguments needed to construct the objective function.\n\nFields:     L: the objective function     ∇L: the gradient of the objective function     ∂²L: the Hessian of the objective function     ∂²L_structure: the structure of the Hessian of the objective function     terms: a vector of dictionaries containing the terms of the objective function\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocationCore.Objectives.L1Regularizer-Tuple{}","page":"Lib","title":"QuantumCollocationCore.Objectives.L1Regularizer","text":"L1Regularizer\n\nCreate an L1 regularizer for the trajectory component. The regularizer is defined as\n\nJ_L1(u) = sum_t absR cdot u_t\n\nwhere (R) is the regularization matrix and (u_t) is the trajectory component at time (t).\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Objectives.MinimumTimeObjective-Tuple{}","page":"Lib","title":"QuantumCollocationCore.Objectives.MinimumTimeObjective","text":"MinimumTimeObjective\n\nA type of objective that counts the time taken to complete a task.\n\nFields:     D: a scaling factor     Δt_indices: the indices of the time steps     eval_hessian: whether to evaluate the Hessian\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Objectives.PairwiseQuadraticRegularizer-Tuple{AbstractVector{<:Real}, AbstractVector{Int64}, Symbol, Symbol}","page":"Lib","title":"QuantumCollocationCore.Objectives.PairwiseQuadraticRegularizer","text":"PairwiseQuadraticRegularizer\n\nCreate a pairwise quadratic regularizer for the trajectory component name with regularization strength R. The regularizer is defined as\n\n    J_v(u) = sum_t frac12 Delta t_t^2 (v_1t - v_2t)^T R (v_1t - v_2t)\n\nwhere v_1 and v_2 are selected by name1 and name2. The indices specify the appropriate block diagonal components of the direct sum vector v⃗.\n\nTODO: Hessian not implemented\n\nFields:     R: the regularization strength     times: the time steps to apply the regularizer     name1: the first name     name2: the second name     timestep_name: the symbol for the timestep     eval_hessian: whether to evaluate the Hessian\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Objectives.PairwiseQuadraticRegularizer-Tuple{NamedTrajectories.StructNamedTrajectory.NamedTrajectory, Union{Float64, AbstractVector{<:Float64}}, AbstractVector{<:Tuple{Symbol, Symbol}}}","page":"Lib","title":"QuantumCollocationCore.Objectives.PairwiseQuadraticRegularizer","text":"PairwiseQuadraticRegularizer\n\nA convenience constructor for creating a PairwiseQuadraticRegularizer for the trajectory component name with regularization strength Rs over the graph graph.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Objectives.PairwiseUnitaryRobustnessObjective-Tuple{}","page":"Lib","title":"QuantumCollocationCore.Objectives.PairwiseUnitaryRobustnessObjective","text":"PairwiseUnitaryRobustnessObjective(;\n    H1::Union{AbstractPiccoloOperator, Nothing}=nothing,\n    H2_error::Union{AbstractPiccoloOperator, Nothing}=nothing,\n    symb1::Symbol=:Ũ⃗1,\n    symb2::Symbol=:Ũ⃗2,\n    eval_hessian::Bool=false,\n)\n\nCreate a control objective which penalizes the sensitivity of the infidelity to the provided operators defined in the subspaces of the control dynamics, thereby realizing robust control.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Objectives.QuadraticRegularizer-Tuple{}","page":"Lib","title":"QuantumCollocationCore.Objectives.QuadraticRegularizer","text":"QuadraticRegularizer\n\nA quadratic regularizer for a trajectory component.\n\nFields:     name: the name of the trajectory component to regularize     times: the times at which to evaluate the regularizer     dim: the dimension of the trajectory component     R: the regularization matrix     baseline: the baseline values for the trajectory component     eval_hessian: whether to evaluate the Hessian of the regularizer     timestep_name: the symbol for the timestep variable\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Objectives.QuadraticSmoothnessRegularizer-Tuple{}","page":"Lib","title":"QuantumCollocationCore.Objectives.QuadraticSmoothnessRegularizer","text":"QuadraticSmoothnessRegularizer\n\nA quadratic smoothness regularizer for a trajectory component.\n\nFields:     name: the name of the trajectory component to regularize     times: the times at which to evaluate the regularizer     R: the regularization matrix     eval_hessian: whether to evaluate the Hessian of the regularizer\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Objectives.QuantumObjective-Tuple{}","page":"Lib","title":"QuantumCollocationCore.Objectives.QuantumObjective","text":"QuantumObjective\n\nA generic objective function for quantum trajectories that use a loss.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Objectives.UnitaryFreePhaseInfidelityObjective-Union{Tuple{}, Tuple{R}} where R<:Real","page":"Lib","title":"QuantumCollocationCore.Objectives.UnitaryFreePhaseInfidelityObjective","text":"UnitaryFreePhaseInfidelityObjective\n\nA type of objective that measures the infidelity of a unitary operator to a target unitary operator, where the target unitary operator is allowed to have phases on qubit subspaces.\n\nFields:     name: the name of the unitary operator in the trajectory     global_name: the name of the global phase in the trajectory     goal: the target unitary operator     Q: a scaling factor     eval_hessian: whether to evaluate the Hessian     subspace: the subspace in which to evaluate the objective\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Objectives.UnitaryInfidelityObjective-Tuple{}","page":"Lib","title":"QuantumCollocationCore.Objectives.UnitaryInfidelityObjective","text":"UnitaryInfidelityObjective\n\nA type of objective that measures the infidelity of a unitary operator to a target unitary operator.\n\nFields:     name: the name of the unitary operator in the trajectory     goal: the target unitary operator     Q: a scaling factor     eval_hessian: whether to evaluate the Hessian     subspace: the subspace in which to evaluate the objective\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Objectives.UnitaryRobustnessObjective-Tuple{}","page":"Lib","title":"QuantumCollocationCore.Objectives.UnitaryRobustnessObjective","text":"UnitaryRobustnessObjective(;     H::::Union{AbstractPiccoloOperator, Nothing}=nothing,     eval_hessian::Bool=false,     symb::Symbol=:Ũ⃗ )\n\nCreate a control objective which penalizes the sensitivity of the infidelity to the provided operator defined in the subspace of the control dynamics, thereby realizing robust control.\n\nThe control dynamics are\n\nU_C(a)= prod_t exp-i H_C(a_t)\n\nIn the control frame, the H operator is (proportional to)\n\nR_Robust(a) = frac1T normH_e_2 sum_t U_C(a_t)^dag H_e U_C(a_t) Delta t\n\nwhere we have adjusted to a unitless expression of the operator.\n\nThe robustness objective is\n\nR_Robust(a) = frac1N normR^2_F\n\nwhere N is the dimension of the Hilbert space.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Objectives.sparse_to_moi-Tuple{SparseArrays.SparseMatrixCSC}","page":"Lib","title":"QuantumCollocationCore.Objectives.sparse_to_moi","text":"sparse_to_moi(A::SparseMatrixCSC)\n\nConverts a sparse matrix to tuple of vector of nonzero indices and vector of nonzero values\n\n\n\n\n\n","category":"method"},{"location":"lib/#Dynamics","page":"Lib","title":"Dynamics","text":"","category":"section"},{"location":"lib/","page":"Lib","title":"Lib","text":"Modules = [QuantumCollocationCore.Dynamics]","category":"page"},{"location":"lib/#QuantumCollocationCore.Dynamics.QuantumDynamics","page":"Lib","title":"QuantumCollocationCore.Dynamics.QuantumDynamics","text":"QuantumDynamics <: AbstractDynamics\n\n\n\n\n\n","category":"type"},{"location":"lib/#Options","page":"Lib","title":"Options","text":"","category":"section"},{"location":"lib/","page":"Lib","title":"Lib","text":"Modules = [QuantumCollocationCore.Options]","category":"page"},{"location":"lib/#QuantumCollocationCore.Options.IpoptOptions","page":"Lib","title":"QuantumCollocationCore.Options.IpoptOptions","text":"Solver options for Ipopt\n\nhttps://coin-or.github.io/Ipopt/OPTIONS.html#OPT_print_options_documentation\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocationCore.Options.PiccoloOptions","page":"Lib","title":"QuantumCollocationCore.Options.PiccoloOptions","text":"PiccoloOptions\n\nOptions for the Piccolo quantum optimal control library.\n\nFields\n\nverbose::Bool = true: Print verbose output\nverbose_evaluator::Bool = false: Print verbose output from the evaluator\nfree_time::Bool = true: Allow free time optimization\ntimesteps_all_equal::Bool = true: Use equal timesteps\nintegrator::Symbol = :pade: Integrator to use\npade_order::Int = 4: Order of the Pade approximation\nrollout_integrator::Function = expv: Integrator to use for rollout\neval_hessian::Bool = false: Evaluate the Hessian\ngeodesic = true: Use the geodesic to initialize the optimization.\nblas_multithreading::Bool = true: Use BLAS multithreading.\nbuild_trajectory_constraints::Bool = true: Build trajectory constraints.\ncomplex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing: Name of the complex control norm constraint.\ncomplex_control_norm_constraint_radius::Float64 = 1.0: Radius of the complex control norm constraint.\nbound_state::Bool = false: Bound the state.\nleakage_suppression::Bool = false: Suppress leakage.\nR_leakage::Float64 = 1.0: Leakage suppression parameter.\nfree_phase_infidelity::Bool = false: Free phase infidelity.\nphase_operators::Union{Nothing, AbstractVector{<:AbstractMatrix{<:Complex}}} = nothing: Phase operators.\nphase_name::Symbol = :ϕ: Name of the phase.\n\n\n\n\n\n","category":"type"},{"location":"lib/#Problem-Solvers","page":"Lib","title":"Problem Solvers","text":"","category":"section"},{"location":"lib/","page":"Lib","title":"Lib","text":"Modules = [QuantumCollocationCore.ProblemSolvers]","category":"page"},{"location":"lib/#QuantumCollocationCore.ProblemSolvers.solve!-Tuple{QuantumControlProblem}","page":"Lib","title":"QuantumCollocationCore.ProblemSolvers.solve!","text":"solve!(prob::QuantumControlProblem;         inittraj=nothing,         savepath=nothing,         maxiter=prob.ipoptoptions.maxiter,         linearsolver=prob.ipoptoptions.linearsolver,         printlevel=prob.ipoptoptions.printlevel,         removeslackvariables=false,         callback=nothing         # statetype=:unitary,         # print_fidelity=false,     )\n\nCall optimization solver to solve the quantum control problem with parameters and callbacks.\n\nArguments\n\nprob::QuantumControlProblem: The quantum control problem to solve.\ninit_traj::NamedTrajectory: Initial guess for the control trajectory. If not provided, a random guess will be generated.\nsave_path::String: Path to save the problem after optimization.\nmax_iter::Int: Maximum number of iterations for the optimization solver.\nlinear_solver::String: Linear solver to use for the optimization solver (e.g., \"mumps\", \"paradiso\", etc).\nprint_level::Int: Verbosity level for the solver.\nremove_slack_variables::Bool: Remove slack variables from the trajectory after optimization.\ncallback::Function: Callback function to call during optimization steps.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Problems","page":"Lib","title":"Problems","text":"","category":"section"},{"location":"lib/","page":"Lib","title":"Lib","text":"Modules = [QuantumCollocationCore.Problems]","category":"page"},{"location":"lib/#QuantumCollocationCore.Problems.QuantumControlProblem","page":"Lib","title":"QuantumCollocationCore.Problems.QuantumControlProblem","text":"mutable struct QuantumControlProblem <: AbstractProblem\n\nStores all the information needed to set up and solve a QuantumControlProblem as well as the solution after the solver terminates.\n\nFields\n\noptimizer::Ipopt.Optimizer: Ipopt optimizer object\n\n\n\n\n\n","category":"type"},{"location":"lib/#QuantumCollocationCore.Problems.get_constraints-Tuple{QuantumControlProblem}","page":"Lib","title":"QuantumCollocationCore.Problems.get_constraints","text":"get_constraints(prob::QuantumControlProblem)\n\nReturn the constraints of the prob::QuantumControlProblem.\n\n\n\n\n\n","category":"method"},{"location":"lib/#QuantumCollocationCore.Problems.get_objective-Tuple{QuantumControlProblem}","page":"Lib","title":"QuantumCollocationCore.Problems.get_objective","text":"get_objective(prob::QuantumControlProblem)\n\nReturn the objective function of the prob::QuantumControlProblem.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Saving-and-Loading","page":"Lib","title":"Saving and Loading","text":"","category":"section"},{"location":"lib/","page":"Lib","title":"Lib","text":"Modules = [QuantumCollocationCore.SaveLoadUtils]","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div align=\"center\">\n  <a href=\"https://github.com/harmoniqs/Piccolo.jl\">\n    <img src=\"assets/logo.svg\" alt=\"Piccolo.jl\" width=\"25%\"/>\n  </a>\n</div>\n\n<div align=\"center\">\n  <table>\n    <tr>\n      <td align=\"center\">\n        <b>Documentation</b>\n        <br>\n        <a href=\"https://docs.harmoniqs.co/QuantumCollocationCore.jl/stable/\">\n          <img src=\"https://img.shields.io/badge/docs-stable-blue.svg\" alt=\"Stable\"/>\n        </a>\n        <a href=\"https://docs.harmoniqs.co/QuantumCollocationCore.jl/dev/\">\n          <img src=\"https://img.shields.io/badge/docs-dev-blue.svg\" alt=\"Dev\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Build Status</b>\n        <br>\n        <a href=\"https://github.com/harmoniqs/QuantumCollocationCore.jl/actions/workflows/CI.yml?query=branch%3Amain\">\n          <img src=\"https://github.com/harmoniqs/QuantumCollocationCore.jl/actions/workflows/CI.yml/badge.svg?branch=main\" alt=\"Build Status\"/>\n        </a>\n        <a href=\"https://codecov.io/gh/harmoniqs/QuantumCollocationCore.jl\">\n          <img src=\"https://codecov.io/gh/harmoniqs/QuantumCollocationCore.jl/branch/main/graph/badge.svg\" alt=\"Coverage\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>License</b>\n        <br>\n        <a href=\"https://opensource.org/licenses/MIT\">\n          <img src=\"https://img.shields.io/badge/License-MIT-yellow.svg\" alt=\"MIT License\"/>\n        </a>\n      </td>\n      <td align=\"center\">\n        <b>Support</b>\n        <br>\n        <a href=\"https://unitary.fund\">\n          <img src=\"https://img.shields.io/badge/Supported%20By-Unitary%20Fund-FFFF00.svg\" alt=\"Unitary Fund\"/>\n        </a>\n      </td>\n    </tr>\n  </table>\n</div>\n\n<div align=\"center\">\n<br>\n</div>","category":"page"},{"location":"#QuantumCollocationCore","page":"Home","title":"QuantumCollocationCore","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QuantumCollocationCore.jl provides a core library for quantum collocation methods. It is designed to be used in conjunction with the QuantumCollocation.jl package and the Piccolo.jl ecosystem, which provides a high-level interface for solving quantum optimal control problems using direct collocation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The underlying nonlinear solver is Ipopt.jl, which is a Julia interface to the Ipopt solver. ","category":"page"}]
}
