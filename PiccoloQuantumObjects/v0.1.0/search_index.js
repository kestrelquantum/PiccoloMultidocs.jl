var documenterSearchIndex = {"docs":
[{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"EditURL = \"../../literate/isomorphisms.jl\"","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"CollapsedDocStrings = true","category":"page"},{"location":"generated/isomorphisms/#Isomorphisms","page":"Isomorphisms","title":"Isomorphisms","text":"","category":"section"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"Linear algebra operations on quantum objects are often performed on real vectors and matrices. We provide isomorphisms to convert between complex and real representations of quantum objects. These isomorphisms are used internally by the QuantumSystem type to perform quantum dynamics.","category":"page"},{"location":"generated/isomorphisms/#Quantum-state-isomorphisms","page":"Isomorphisms","title":"Quantum state isomorphisms","text":"","category":"section"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"ket_to_iso is the real isomorphism of a quantum state ψ ∈ ℂⁿ\niso_to_ket is the inverse isomorphism of a real vector ψ̃ ∈ ℝ²ⁿ","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"ψ = [1; 2] + im * [3; 4]\nψ̃ = ket_to_iso(ψ)","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"iso_to_ket(ψ̃)","category":"page"},{"location":"generated/isomorphisms/#Quantum-operator-isomorphisms","page":"Isomorphisms","title":"Quantum operator isomorphisms","text":"","category":"section"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"We often need to convert a complex matrix U to a real vector Ũ⃗. We provoide the following isomorphisms to convert between the two representations.","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"iso_vec_to_operator(Ũ⃗::AbstractVector{ℝ})\noperator_to_iso_vec(U::AbstractVector{ℂ})\niso_vec_to_iso_operator(Ũ⃗::AbstractVector{ℝ})\niso_operator_to_iso_vec(Ũ::AbstractMatrix{ℝ})\niso_operator_to_operator(Ũ::AbstractMatrix{ℝ})\noperator_to_iso_operator(U::AbstractMatrix{ℂ})","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"In additon, we provide mat(x::AbstractVector) to convert a vector x into a square matrix, as the inverse to Base's vec.","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"Julia uses column-major order.","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"U = [1 5; 2 6] + im * [3 7; 4 8]\nŨ⃗ = operator_to_iso_vec(U)","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"iso_vec_to_operator(Ũ⃗)","category":"page"},{"location":"generated/isomorphisms/#Density-matrix-isomorphisms","page":"Isomorphisms","title":"Density matrix isomorphisms","text":"","category":"section"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"The isomorphisms for density matrices are:","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"density_to_iso_vec(ρ::AbstractMatrix{ℂ})\niso_vec_to_density(ρ̃::AbstractVector{ℝ})","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"warning: Warning\nThe isomorphism density_to_iso_vec is not the same as operator_to_iso_vec.","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"ρ = [1 2; 3 4] + im * [5 6; 7 8]\nρ̃⃗ = density_to_iso_vec(ρ)","category":"page"},{"location":"generated/isomorphisms/#Quantum-dynamics-isomorphisms","page":"Isomorphisms","title":"Quantum dynamics isomorphisms","text":"","category":"section"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"The quantum dynamics isomorphisms, which correspond to these state transformations, are handled internally by the QuantumSystem type.","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"The Isomorphisms.iso isomorphism of a Hamiltonian H is:","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"textiso(H) = widetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"where Im(H) and Re(H) are the imaginary and real parts of H and the tilde indicates the standard isomorphism of a complex valued matrix:","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"widetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"Hence, the generator Isomorphisms.G associated to a Hamiltonian H is:","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"G(H) = textiso(- i widetildeH) = mqty(1  0  0  1) otimes Im(H) - mqty(0  -1  1  0) otimes Re(H)","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"","category":"page"},{"location":"generated/isomorphisms/","page":"Isomorphisms","title":"Isomorphisms","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/","page":"Library","title":"Library","text":"CollapsedDocStrings = true","category":"page"},{"location":"lib/#Quantum-Systems","page":"Library","title":"Quantum Systems","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [PiccoloQuantumObjects.QuantumSystems]","category":"page"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","text":"AbstractQuantumSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::AbstractVector{<:AbstractMatrix{<:Number}}\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}};\n    kwargs...\n)\nOpenQuantumSystem(\n    H_drift::Matrix{<:Number}, H_drives::AbstractVector{Matrix{<:Number}}; \n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[], \n    kwargs...\n)\nOpenQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nOpenQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nOpenQuantumSystem(H::Function, n_drives::Int; kwargs...)\n\nConstructs an OpenQuantumSystem object from the drift and drive Hamiltonian terms and dissipation operators.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem(H_drift::Matrix{<:Number}, H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H::Function, n_drives::Int; kwargs...)\n\nConstructs a QuantumSystem object from the drift and drive Hamiltonian terms.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drift","text":"get_drift(sys::AbstractQuantumSystem)\n\nReturns the drift Hamiltonian of the system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drives","text":"get_drives(sys::AbstractQuantumSystem)\n\nReturns the drive Hamiltonians of the system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Composite-Quantum-Systems","page":"Library","title":"Composite Quantum Systems","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [PiccoloQuantumObjects.CompositeQuantumSystems]","category":"page"},{"location":"lib/#PiccoloQuantumObjects.CompositeQuantumSystems.CompositeQuantumSystem","page":"Library","title":"PiccoloQuantumObjects.CompositeQuantumSystems.CompositeQuantumSystem","text":"CompositeQuantumSystem <: AbstractQuantumSystem\n\nA composite quantum system consisting of subsystems. Couplings between subsystems can be additionally defined. Subsystem drives are always appended to any new coupling drives.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.CompositeQuantumSystems.lift","page":"Library","title":"PiccoloQuantumObjects.CompositeQuantumSystems.lift","text":"lift(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\n\nLift an operator acting on the i-th subsystem within subsystem_levels to an operator acting on the entire system spanning subsystem_levels.\n\n\n\n\n\n","category":"function"},{"location":"lib/#Gates","page":"Library","title":"Gates","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [PiccoloQuantumObjects.Gates]","category":"page"},{"location":"lib/#PiccoloQuantumObjects.Gates.GATES","page":"Library","title":"PiccoloQuantumObjects.Gates.GATES","text":"A constant dictionary GATES containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix.\n\nGATES[:I] - Identity: Leaves the state unchanged.\nGATES[:X] - Pauli-X (NOT): Flips the qubit state.\nGATES[:Y] - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere.\nGATES[:Z] - Pauli-Z: Flips the phase of the qubit state.\nGATES[:H] - Hadamard: Creates superposition by transforming basis states.\nGATES[:CX] - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1⟩.\nGATES[:CZ] - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1⟩.\nGATES[:XI] - Complex: A gate for complex operations.\nGATES[:sqrtiSWAP] - Square root of iSWAP: Partially swaps two qubits with a phase.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#PiccoloQuantumObjects.Gates.PAULIS","page":"Library","title":"PiccoloQuantumObjects.Gates.PAULIS","text":"The 2×2 Pauli matrics and identity.\n\n\n\n\n\n","category":"constant"},{"location":"lib/#Embedded-Operators","page":"Library","title":"Embedded Operators","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [PiccoloQuantumObjects.EmbeddedOperators]","category":"page"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","text":"AbstractPiccoloOperator\n\nUnion type for operators.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator\n\nEmbedded operator type to represent an operator embedded in a subspace of a larger  quantum system.\n\nFields\n\noperator::Matrix{ComplexF64}: Embedded operator of size    prod(subsystem_levels) x prod(subsystem_levels).\nsubspace::Vector{Int}: Indices of the subspace the operator is embedded in.\nsubsystem_levels::Vector{Int}: Levels of the subsystems in the composite system.\n\n\n\n\n\n","category":"type"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system, where  the subsystem_indices list the subspaces at which the operator is defined, and the subsystem_levels list the levels of the subsystems in which the operator is embedded. \n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\n\nCreate an embedded operator. The operator is embedded at the subspace of the system spanned by the subsystem_levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, QuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::AbstractMatrix{<:Number}, system::QuantumSystem; kwargs...)\n\nEmbed the subspace_operator into a quantum system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","text":"embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator)\n\nEmbed the subspace_operator in the subspace of a larger embedded_operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Union{Tuple{R}, Tuple{AbstractMatrix{R}, AbstractVector{Int64}, Int64}} where R<:Number","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","text":"embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int)\n\nEmbed an operator in the subspace of a larger matrix of size levels x levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices-Tuple{Int64, AbstractVector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices","text":"get_enr_subspace_indices(excitation_restriction::Int, subsystem_levels::AbstractVector{Int})\n\nGet the indices for the subspace of the quantum system with an excitation restriction.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","text":"get_iso_vec_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_iso_vec_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_iso_vec_leakage_indices(op::EmbeddedOperator)\n\nGet the indices for the leakage in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","text":"get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the subspace in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","text":"get_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_leakage_indices(op::EmbeddedOperator)\n\nGet the indices for the states that are outside of the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)    \nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int})\n\nUnembed a subspace operator from the matrix. This is equivalent to calling  matrix[subspace, subspace].\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator)\n\nUnembed a sub-matrix from the op at the subspace defined by embedded_op.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{EmbeddedOperator}","page":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(embedded_op::EmbeddedOperator)::Matrix{ComplexF64}\n\nUnembed an embedded operator, returning the original operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Isomorphisims","page":"Library","title":"Isomorphisims","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [PiccoloQuantumObjects.Isomorphisms]","category":"page"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.G-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.G","text":"G(H::AbstractMatrix)::Matrix{Float64}\n\nReturns the isomorphism of -iH, i.e. G(H) = textiso(-iH).\n\nSee also Isomorphisms.iso, Isomorphisms.H.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.H-Tuple{AbstractMatrix{<:Real}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.H","text":"H(G::AbstractMatrix{<:Real})\n\nReturns the inverse of G(H) = iso(-iH), i.e. returns H.\n\nSee also Isomorphisms.iso, Isomorphisms.G.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.ad_vec-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ad_vec","text":"ad_vec(H::AbstractMatrix{ℂ}; anti::Bool=false) where ℂ <: Number\n\nReturns the vectorized adjoint action of a matrix H:\n\ntextad_vec(H) = mqty(1  0  0  1) otimes H - (-1)^textanti mqty(0  1  1  0) otimes H^*\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec","text":"density_to_iso_vec(ρ::AbstractMatrix{<:Number})\n\nReturns the isomorphism ρ⃗̃ = ket_to_iso(vec(ρ)) of a density matrix ρ\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso-Tuple{AbstractMatrix{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso","text":"iso(H::AbstractMatrix{<:Number})\n\nReturns the isomorphism of H:\n\niso(H) = widetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nwhere Im(H) and Re(H) are the imaginary and real parts of H and the tilde  indicates the standard isomorphism of a complex valued matrix:\n\nwidetildeH = mqty(1  0  0  1) otimes Re(H) + mqty(0  -1  1  0) otimes Im(H)\n\nSee also Isomorphisms.G, Isomorphisms.H.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_D-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_D","text":"iso_D(L::AbstractMatrix{ℂ}) where ℂ <: Number\n\nReturns the isomorphic representation of the Lindblad dissipator L.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{ℝ}}, Tuple{ℝ}} where ℝ<:Real","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec","text":"iso_operator_to_iso_vec(Ũ::AbstractMatrix{ℝ}) where ℝ <: Real\n\nConvert a real matrix Ũ representing an isomorphism operator into a real vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator-Tuple{Any}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator","text":"iso_operator_to_operator(Ũ)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_to_ket-Tuple{AbstractVector{<:Real}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_to_ket","text":"iso_to_ket(ψ̃::AbstractVector{<:Real})\n\nConvert a real isomorphism vector ψ̃ into a ket vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density-Tuple{AbstractVector{<:Real}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density","text":"iso_vec_to_density(ρ⃗̃::AbstractVector{<:Real})\n\nReturns the density matrix ρ from its isomorphism ρ⃗̃\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{ℝ}}, Tuple{ℝ}} where ℝ<:Real","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator","text":"iso_vec_to_iso_operator(Ũ⃗::AbstractVector{ℝ}) where ℝ <: Real\n\nConvert a real vector Ũ⃗ into a real matrix representing an isomorphism operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{ℝ}}, Tuple{ℝ}} where ℝ<:Real","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator","text":"iso_vec_to_operator(Ũ⃗::AbstractVector{ℝ}) where ℝ <: Real\n\nConvert a real vector Ũ⃗ into a complex matrix representing an operator.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.ket_to_iso-Tuple{AbstractVector{<:Number}}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ket_to_iso","text":"ket_to_iso(ψ::AbstractVector{<:Number})\n\nConvert a ket vector ψ into a complex vector with real and imaginary parts.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.mat-Tuple{AbstractVector}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.mat","text":"mat(x::AbstractVector)\n\nConvert a vector x into a square matrix. The length of x must be a perfect square.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator-Tuple{Any}","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator","text":"operator_to_iso_operator(U)\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","page":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec","text":"operator_to_iso_vec(U::AbstractMatrix{ℂ}) where ℂ <: Number\n\nConvert a complex matrix U representing an operator into a real vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Quantum-Object-Utilities","page":"Library","title":"Quantum Object Utilities","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [PiccoloQuantumObjects.QuantumObjectUtils]","category":"page"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.annihilate-Tuple{Int64}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.annihilate","text":"annihilate(levels::Int)\n\nGet the annihilation operator for a system with levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.create-Tuple{Int64}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.create","text":"create(levels::Int)\n\nGet the creation operator for a system with levels.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_identity","text":"haar_identity(n::Int, radius::Number)\n\nGenerate a random unitary matrix close to the identity matrix using the Haar measure for  an n-dimensional system with a given radius. The smaller the radius, the closer the matrix will be to the identity.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_random-Tuple{Int64}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_random","text":"haar_random(n::Int)\n\nGenerate a random unitary matrix using the Haar measure for an n-dimensional system.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring-Tuple{String}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring","text":"ket_from_bitstring(ket::String)\n\nGet the state vector for a qubit system given a ket string ket of 0s and 1s.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string","text":"ket_from_string(\n    ket::String,\n    levels::Vector{Int};\n    level_dict=Dict(:g => 0, :e => 1, :f => 2, :h => 2),\n    return_states=false\n)\n\nConstruct a quantum state from a string ket representation.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string-Tuple{String}","page":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string","text":"operator_from_string(operator::String; lookup=PAULIS)\n\nReduce the string (each character is one key) via operators from a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"lib/#Quantum-System-Utilities","page":"Library","title":"Quantum System Utilities","text":"","category":"section"},{"location":"lib/","page":"Library","title":"Library","text":"Modules = [PiccoloQuantumObjects.QuantumSystemUtils]","category":"page"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractQuantumSystem}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","text":"is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...)\n\nCheck if the gate is reachable using the given system.\n\nKeyword Arguments\n\nuse_drift::Bool=true: include drift Hamiltonian in the generators\nkwargs...: keyword arguments for is_reachable\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}}","page":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","text":"is_reachable(gate, hamiltonians; kwargs...)\n\nCheck if the gate is reachable using the given hamiltonians.\n\nArguments\n\ngate::AbstractMatrix: target gate\nhamiltonians::AbstractVector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nsubspace::AbstractVector{<:Int}=1:size(gate, 1): subspace indices\ncompute_basis::Bool=true: compute the basis or use the Hamiltonians directly\nremove_trace::Bool=true: remove trace from generators\nverbose::Bool=true: print information about the operator algebra\natol::Float32=eps(Float32): absolute tolerance\n\nSee also QuantumSystemUtils.operator_algebra.\n\n\n\n\n\n","category":"method"},{"location":"lib/#PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","page":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra","text":"operator_algebra(generators; kwargs...)\n\nCompute the Lie algebra basis for the given generators.\n\nArguments\n\ngenerators::Vector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nreturn_layers::Bool=false: return the Lie tree layers\nnormalize::Bool=false: normalize the basis\nverbose::Bool=false: print information\nremove_trace::Bool=true: remove trace from generators\n\n\n\n\n\n","category":"method"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"EditURL = \"../../literate/quantum_objects.jl\"","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"CollapsedDocStrings = true","category":"page"},{"location":"generated/quantum_objects/#Quantum-Objects","page":"Quantum Objects","title":"Quantum Objects","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n⊗ = kron;\nnothing #hide","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Quantum states and operators are represented as complex vectors and matrices. We provide a number of convenient ways to construct these objects. We also provide some tools for working with these objects, such as embedding operators in larger Hilbert spaces and selecting subspace indices.","category":"page"},{"location":"generated/quantum_objects/#Quantum-states","page":"Quantum Objects","title":"Quantum states","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"We can construct quantum states from bitstrings or string representations. The string representations use atomic notation (ground state g, excited state e, etc.).","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Ground state in a 2-level system.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"ket_from_string(\"g\", [2])","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Superposition state coupled to a ground state in two 2-level systems.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"ket_from_string(\"(g+e)g\", [2,2])","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"|01⟩ in a 2-qubit system.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"ket_from_bitstring(\"01\")","category":"page"},{"location":"generated/quantum_objects/#Quantum-operators","page":"Quantum Objects","title":"Quantum operators","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Frequently used operators are provided in PAULIS and GATES.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"GATES","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.Gates.GATES-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.Gates.GATES","text":"A constant dictionary GATES containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix.\n\nGATES[:I] - Identity: Leaves the state unchanged.\nGATES[:X] - Pauli-X (NOT): Flips the qubit state.\nGATES[:Y] - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere.\nGATES[:Z] - Pauli-Z: Flips the phase of the qubit state.\nGATES[:H] - Hadamard: Creates superposition by transforming basis states.\nGATES[:CX] - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1⟩.\nGATES[:CZ] - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1⟩.\nGATES[:XI] - Complex: A gate for complex operations.\nGATES[:sqrtiSWAP] - Square root of iSWAP: Partially swaps two qubits with a phase.\n\n\n\n\n\n","category":"constant"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Quantum operators can also be constructed from strings.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"operator_from_string(\"X\")","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"operator_from_string(\"XZ\")","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Annihilation and creation operators are provided for oscillator systems.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"a = annihilate(3)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"a⁺ = create(3)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"a'a","category":"page"},{"location":"generated/quantum_objects/#Random-operators","page":"Quantum Objects","title":"Random operators","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The haar_random function draws random unitary operators according to the Haar measure.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"haar_random(3)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"If we want to generate random operations that are close to the identity, we can use the haar_identity function.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"haar_identity(2, 0.1)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"A smaller radius means the random operator is closer to the identity.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"haar_identity(2, 0.01)","category":"page"},{"location":"generated/quantum_objects/#Embedded-operators","page":"Quantum Objects","title":"Embedded operators","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Sometimes we want to embed a quantum operator into a larger Hilbert space, mathcalH, which we decompose into subspace and leakage components:","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"    mathcalH = mathcalH_textsubspace oplus mathcalH_textleakage","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"In quantum computing, the computation is encoded in a subspace, while the remaining leakage states should be avoided.","category":"page"},{"location":"generated/quantum_objects/#The-embed-and-unembed-functions","page":"Quantum Objects","title":"The embed and unembed functions","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The embed function allows to embed a quantum operator in a larger Hilbert space.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"embed","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.embed-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","text":"embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int)\n\nEmbed an operator in the subspace of a larger matrix of size levels x levels.\n\n\n\n\n\nembed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator)\n\nEmbed the subspace_operator in the subspace of a larger embedded_operator.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The unembed function allows to unembed a quantum operator from a larger Hilbert space.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"unembed","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.unembed-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","text":"unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int})\n\nUnembed a subspace operator from the matrix. This is equivalent to calling  matrix[subspace, subspace].\n\n\n\n\n\nunembed(embedded_op::EmbeddedOperator)::Matrix{ComplexF64}\n\nUnembed an embedded operator, returning the original operator.\n\n\n\n\n\nunembed(op::AbstractMatrix, embedded_op::EmbeddedOperator)\n\nUnembed a sub-matrix from the op at the subspace defined by embedded_op.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Embed a two-level X gate into a multilevel system.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"levels = 3\nX = GATES[:X]\nsubspace_indices = 1:2\nX_embedded = embed(X, subspace_indices, levels)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Unembed to retrieve the original operator.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"X_original = unembed(X_embedded, subspace_indices)","category":"page"},{"location":"generated/quantum_objects/#The-EmbeddedOperator-type","page":"Quantum Objects","title":"The EmbeddedOperator type","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The EmbeddedOperator type stores information about an operator embedded in the subspace of a larger quantum system.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"EmbeddedOperator","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator\n\nEmbedded operator type to represent an operator embedded in a subspace of a larger  quantum system.\n\nFields\n\noperator::Matrix{ComplexF64}: Embedded operator of size    prod(subsystem_levels) x prod(subsystem_levels).\nsubspace::Vector{Int}: Indices of the subspace the operator is embedded in.\nsubsystem_levels::Vector{Int}: Levels of the subsystems in the composite system.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"We construct an embedded operator in the same manner as the embed function.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{Matrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\n\nCreate an embedded operator. The operator is embedded at the subspace of the system spanned by the subsystem_levels.\n\n\n\n\n\n","category":"method"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Embed an X gate in the first qubit's subspace within two 3-level systems.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"gate = GATES[:X] ⊗ GATES[:I]\nsubsystem_levels = [3, 3]\nsubspace_indices = get_subspace_indices([1:2, 1:2], subsystem_levels)\nembedded_operator = EmbeddedOperator(gate, subspace_indices, subsystem_levels)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Show the full operator.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"embedded_operator.operator .|> real |> sparse","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Get the original operator back.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"unembed(embedded_operator) .|> real |> sparse","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Embedded operators for composite systems are also supported.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n)","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","text":"EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n)\n\nEmbed the subspace_operator into the provided subspaces of a composite system, where  the subsystem_indices list the subspaces at which the operator is defined, and the subsystem_levels list the levels of the subsystems in which the operator is embedded. \n\n\n\n\n\n","category":"method"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"This is a two step process.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The provided subspace operator is lift-ed  from the subsystem_indices where  it is defined into the space spanned by the composite system's subspaces.\nThe lifted operator is embedded into the full Hilbert space spanned by the  subsystem_levels.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Embed a CZ gate with control qubit 1 and target qubit 3 into a composite system made up of three 3-level systems. An identity is performed on qubit 2.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"subsystem_levels = [3, 3, 3]\nsubspaces = [1:2, 1:2, 1:2]\nembedded_operator = EmbeddedOperator(GATES[:CZ], [1, 3], subspaces, subsystem_levels)\nunembed(embedded_operator) .|> real |> sparse","category":"page"},{"location":"generated/quantum_objects/#Subspace-and-leakage-indices","page":"Quantum Objects","title":"Subspace and leakage indices","text":"","category":"section"},{"location":"generated/quantum_objects/#The-get_subspace_indices-function","page":"Quantum Objects","title":"The get_subspace_indices function","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The get_subspace_indices function is a convenient way to get the indices of a subspace in a larger quantum system.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_subspace_indices","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","text":"get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)    \nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the provided subspace of the quantum system.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Its dual function is get_leakage_indices.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_subspace_indices(1:2, 5) |> collect, get_leakage_indices(1:2, 5) |> collect","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Composite systems are supported. Get the indices of the two-qubit subspace within two 3-level systems.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_subspace_indices([1:2, 1:2], [3, 3])","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Qubits are assumed if the indices are not provided.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_subspace_indices([3, 3])","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_leakage_indices([3, 3])","category":"page"},{"location":"generated/quantum_objects/#Excitation-number-restrictions","page":"Quantum Objects","title":"Excitation number restrictions","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Sometimes we want to cap the number of excitations we allow across a composite system. For example, if we want to restrict ourselves to the ground and single excitation states of two 3-level systems:","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_enr_subspace_indices(1, [3, 3])","category":"page"},{"location":"generated/quantum_objects/#The-get_iso_vec_subspace_indices-function","page":"Quantum Objects","title":"The get_iso_vec_subspace_indices function","text":"","category":"section"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"For isomorphic operators, the get_iso_vec_subspace_indices function can be used to find the appropriate vector indices of the equivalent operator subspace. See also, Isomorphisms#Quantum-operator-isomorphisms.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_iso_vec_subspace_indices","category":"page"},{"location":"generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices-generated-quantum_objects","page":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","text":"get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator)\n\nGet the indices for the subspace in the isomorphic vector space for operators.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Its dual function is get_iso_vec_leakage_indices, which by default only returns the leakage indices of the blocks:","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"mathcalH_textsubspace otimes mathcalH_textsubspacequad\nmathcalH_textsubspace otimes mathcalH_textleakagequad\nmathcalH_textleakage otimes mathcalH_textsubspace","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"allowing for leakage-suppressing code to disregard the uncoupled pure-leakage space.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"get_iso_vec_subspace_indices(1:2, 3)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"without_pure_leakage = get_iso_vec_leakage_indices(1:2, 3)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"Show the pure-leakage indices.","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"with_pure_leakage = get_iso_vec_leakage_indices(1:2, 3, ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage)","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"The pure-leakage indices can grow quickly!","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"without_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4])\nwith_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4], ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage) |> length","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"","category":"page"},{"location":"generated/quantum_objects/","page":"Quantum Objects","title":"Quantum Objects","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"EditURL = \"../../literate/quantum_systems.jl\"","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"CollapsedDocStrings = true","category":"page"},{"location":"generated/quantum_systems/#Abstract-Quantum-Systems","page":"Quantum Systems","title":"Abstract Quantum Systems","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n⊗ = kron;\nnothing #hide","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"AbstractQuantumSystem","category":"page"},{"location":"generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem-generated-quantum_systems","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","text":"AbstractQuantumSystem\n\nAbstract type for defining systems.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_systems/#Quantum-Systems","page":"Quantum Systems","title":"Quantum Systems","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"The QuantumSystem type is used to represent a quantum system with a drift Hamiltonian and a set of drive Hamiltonians,","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"H = H_textdrift + sum_i a_i H_textdrives^(i)","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"QuantumSystem","category":"page"},{"location":"generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-generated-quantum_systems","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","text":"QuantumSystem(H_drift::Matrix{<:Number}, H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H::Function, n_drives::Int; kwargs...)\n\nConstructs a QuantumSystem object from the drift and drive Hamiltonian terms.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"QuantumSystem's are containers for quantum dynamics. Internally, they compute the necessary isomorphisms to perform the dynamics in a real vector space.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"H_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsystem = QuantumSystem(H_drift, H_drives)\n\na_drives = [1, 0]\nsystem.H(a_drives)","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"To extract the drift and drive Hamiltonians from a QuantumSystem, use the get_drift and get_drives functions.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"get_drift(system) |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Get the X drive.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"drives = get_drives(system)\ndrives[1] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"And the Y drive.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"drives[2] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"note: Note\nWe can also construct a QuantumSystem directly from a Hamiltonian function. Internally, ForwardDiff.jl is used to compute the drives.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"H(a) = PAULIS[:Z] + a[1] * PAULIS[:X] + a[2] * PAULIS[:Y]\nsystem = QuantumSystem(H, 2)\nget_drives(system)[1] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Create a noise model with a confusion matrix.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"function H(a; C::Matrix{Float64}=[1.0 0.0; 0.0 1.0])\n    b = C * a\n    return b[1] * PAULIS.X + b[2] * PAULIS.Y\nend\n\nsystem = QuantumSystem(a -> H(a, C=[0.99 0.01; -0.01 1.01]), 2)\nconfused_drives = get_drives(system)\nconfused_drives[1] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"confused_drives[2] |> sparse","category":"page"},{"location":"generated/quantum_systems/#Open-quantum-systems","page":"Quantum Systems","title":"Open quantum systems","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"We can also construct an OpenQuantumSystem with Lindblad dynamics, enabling a user to pass a list of dissipation operators.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"OpenQuantumSystem","category":"page"},{"location":"generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-generated-quantum_systems","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","text":"OpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::AbstractVector{<:AbstractMatrix{<:Number}}\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}};\n    kwargs...\n)\nOpenQuantumSystem(\n    H_drift::Matrix{<:Number}, H_drives::AbstractVector{Matrix{<:Number}}; \n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[], \n    kwargs...\n)\nOpenQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nOpenQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nOpenQuantumSystem(H::Function, n_drives::Int; kwargs...)\n\nConstructs an OpenQuantumSystem object from the drift and drive Hamiltonian terms and dissipation operators.\n\n\n\n\n\n","category":"type"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Add a dephasing and annihilation error channel.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"H_drives = [PAULIS[:X]]\na = annihilate(2)\ndissipation_operators = [a'a, a]\nsystem = OpenQuantumSystem(H_drives, dissipation_operators=dissipation_operators)\nsystem.dissipation_operators[1] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"system.dissipation_operators[2] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"warning: Warning\nThe Hamiltonian part system.H excludes the Lindblad operators. This is also true for functions that report properties of system.H, such as get_drift, get_drives, and is_reachable.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"get_drift(system) |> sparse","category":"page"},{"location":"generated/quantum_systems/#Composite-quantum-systems","page":"Quantum Systems","title":"Composite quantum systems","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"A CompositeQuantumSystem is constructed from a list of subsystems and their interactions. The interaction, in the form of drift or drive Hamiltonian, acts on the full Hilbert space. The subsystems, with their own drift and drive Hamiltonians, are internally lifted to the full Hilbert space.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"system_1 = QuantumSystem([PAULIS[:X]])\nsystem_2 = QuantumSystem([PAULIS[:Y]])\nH_drift = PAULIS[:Z] ⊗ PAULIS[:Z]\nsystem = CompositeQuantumSystem(H_drift, [system_1, system_2]);\nnothing #hide","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"The drift Hamiltonian is the ZZ coupling.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"get_drift(system) |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"The drives are the X and Y operators on the first and second subsystems.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"drives = get_drives(system)\ndrives[1] |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"drives[2] |> sparse","category":"page"},{"location":"generated/quantum_systems/#The-lift-function","page":"Quantum Systems","title":"The lift function","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"To lift operators acting on a subsystem into the full Hilbert space, use lift.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"lift","category":"page"},{"location":"generated/quantum_systems/#PiccoloQuantumObjects.CompositeQuantumSystems.lift-generated-quantum_systems","page":"Quantum Systems","title":"PiccoloQuantumObjects.CompositeQuantumSystems.lift","text":"lift(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\n\nLift an operator acting on the i-th subsystem within subsystem_levels to an operator acting on the entire system spanning subsystem_levels.\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Create an a + a' operator acting on the 1st subsystem of a qutrit and qubit system.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"subspace_levels = [3, 2]\nlift(create(3) + annihilate(3), 1, subspace_levels) .|> real |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Create IXI operator on the 2nd qubit in a 3-qubit system.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"lift(PAULIS[:X], 2, 3) .|> real |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Create an XX operator acting on qubits 3 and 4 in a 4-qubit system.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"lift([PAULIS[:X], PAULIS[:X]], [3, 4], 4) .|> real |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"We can also lift an operator that entangles different subspaces by passing the indices of the entangled subsystems.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"#_Here's another way to create an XX operator acting on qubits 3 and 4 in a 4-qubit system._\nlift(kron(PAULIS[:X], PAULIS[:X]), [3, 4], 4) .|> real |> sparse","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Lift a CX gate acting on the 1st and 3rd qubits in a 3-qubit system. The result is independent of the state of the second qubit.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"lift(GATES[:CX], [1, 3], 3) .|> real |> sparse","category":"page"},{"location":"generated/quantum_systems/#Reachability-tests","page":"Quantum Systems","title":"Reachability tests","text":"","category":"section"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Whether a quantum system can be used to reach a target state or operator can be tested by computing the dynamical Lie algebra. Access to this calculation is provided by the is_reachable function.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"is_reachable","category":"page"},{"location":"generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-generated-quantum_systems","page":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","text":"is_reachable(gate, hamiltonians; kwargs...)\n\nCheck if the gate is reachable using the given hamiltonians.\n\nArguments\n\ngate::AbstractMatrix: target gate\nhamiltonians::AbstractVector{<:AbstractMatrix}: generators of the Lie algebra\n\nKeyword Arguments\n\nsubspace::AbstractVector{<:Int}=1:size(gate, 1): subspace indices\ncompute_basis::Bool=true: compute the basis or use the Hamiltonians directly\nremove_trace::Bool=true: remove trace from generators\nverbose::Bool=true: print information about the operator algebra\natol::Float32=eps(Float32): absolute tolerance\n\nSee also QuantumSystemUtils.operator_algebra.\n\n\n\n\n\nis_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...)\n\nCheck if the gate is reachable using the given system.\n\nKeyword Arguments\n\nuse_drift::Bool=true: include drift Hamiltonian in the generators\nkwargs...: keyword arguments for is_reachable\n\n\n\n\n\n","category":"function"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Y can be reached by commuting Z and X.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"system = QuantumSystem(PAULIS[:Z], [PAULIS[:X]])\nis_reachable(PAULIS[:Y], system)","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"Y cannot be reached by X alone.","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"system = QuantumSystem([PAULIS[:X]])\nis_reachable(PAULIS[:Y], system)","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"","category":"page"},{"location":"generated/quantum_systems/","page":"Quantum Systems","title":"Quantum Systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PiccoloQuantumObjects","category":"page"},{"location":"#PiccoloQuantumObjects","page":"Home","title":"PiccoloQuantumObjects","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PiccoloQuantumObjects.","category":"page"}]
}
