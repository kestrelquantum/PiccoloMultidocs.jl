[{"id":3,"pagetitle":"Home","title":"PiccoloQuantumObjects","ref":"/PiccoloQuantumObjects/stable/#PiccoloQuantumObjects","content":" PiccoloQuantumObjects Documentation for  PiccoloQuantumObjects ."},{"id":6,"pagetitle":"Isomorphisms","title":"Isomorphisms","ref":"/PiccoloQuantumObjects/stable/generated/isomorphisms/#Isomorphisms","content":" Isomorphisms using PiccoloQuantumObjects\nusing SparseArrays # for visualization Linear algebra operations on quantum objects are often performed on real vectors and matrices. We provide isomorphisms to convert between complex and real representations of quantum objects. These isomorphisms are used internally by the  QuantumSystem  type to perform quantum dynamics."},{"id":7,"pagetitle":"Isomorphisms","title":"Quantum state isomorphisms","ref":"/PiccoloQuantumObjects/stable/generated/isomorphisms/#Quantum-state-isomorphisms","content":" Quantum state isomorphisms ket_to_iso  is the real isomorphism of a quantum state  ψ ∈ ℂⁿ iso_to_ket  is the inverse isomorphism of a real vector  ψ̃ ∈ ℝ²ⁿ ψ = [1; 2] + im * [3; 4]\nψ̃ = ket_to_iso(ψ) 4-element Vector{Int64}:\n 1\n 2\n 3\n 4 iso_to_ket(ψ̃) 2-element Vector{Complex{Int64}}:\n 1 + 3im\n 2 + 4im"},{"id":8,"pagetitle":"Isomorphisms","title":"Quantum operator isomorphisms","ref":"/PiccoloQuantumObjects/stable/generated/isomorphisms/#Quantum-operator-isomorphisms","content":" Quantum operator isomorphisms We often need to convert a complex matrix  U  to a real vector  Ũ⃗ . We provoide the following isomorphisms to convert between the two representations. iso_vec_to_operator (Ũ⃗::AbstractVector{ℝ}) operator_to_iso_vec (U::AbstractVector{ℂ}) iso_vec_to_iso_operator (Ũ⃗::AbstractVector{ℝ}) iso_operator_to_iso_vec (Ũ::AbstractMatrix{ℝ}) iso_operator_to_operator (Ũ::AbstractMatrix{ℝ}) operator_to_iso_operator (U::AbstractMatrix{ℂ}) In additon, we provide  mat (x::AbstractVector)  to convert a vector  x  into a square matrix, as the inverse to Base's  vec . Julia uses column-major order. U = [1 5; 2 6] + im * [3 7; 4 8]\nŨ⃗ = operator_to_iso_vec(U) 8-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8 iso_vec_to_operator(Ũ⃗) 2×2 Matrix{Complex{Int64}}:\n 1+3im  5+7im\n 2+4im  6+8im"},{"id":9,"pagetitle":"Isomorphisms","title":"Density matrix isomorphisms","ref":"/PiccoloQuantumObjects/stable/generated/isomorphisms/#Density-matrix-isomorphisms","content":" Density matrix isomorphisms The isomorphisms for density matrices are: density_to_iso_vec (ρ::AbstractMatrix{ℂ}) iso_vec_to_density (ρ̃::AbstractVector{ℝ}) Warning The isomorphism  density_to_iso_vec  is not the same as  operator_to_iso_vec . ρ = [1 2; 3 4] + im * [5 6; 7 8]\nρ̃⃗ = density_to_iso_vec(ρ) 8-element Vector{Int64}:\n 1\n 3\n 2\n 4\n 5\n 7\n 6\n 8"},{"id":10,"pagetitle":"Isomorphisms","title":"Quantum dynamics isomorphisms","ref":"/PiccoloQuantumObjects/stable/generated/isomorphisms/#Quantum-dynamics-isomorphisms","content":" Quantum dynamics isomorphisms The quantum dynamics isomorphisms, which correspond to these state transformations, are handled internally by the  QuantumSystem  type. The  Isomorphisms.iso  isomorphism of a Hamiltonian  $H$  is: \\[\\text{iso}(H) := \\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] where  $\\Im(H)$  and  $\\Re(H)$  are the imaginary and real parts of  $H$  and the tilde indicates the standard isomorphism of a complex valued matrix: \\[\\widetilde{H} := \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] Hence, the generator  Isomorphisms.G  associated to a Hamiltonian  $H$  is: \\[G(H) := \\text{iso}(- i \\widetilde{H}) = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Im(H) - \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Re(H)\\] This page was generated using  Literate.jl ."},{"id":13,"pagetitle":"Quantum Objects","title":"Quantum Objects","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Quantum-Objects","content":" Quantum Objects using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n⊗ = kron; Quantum states and operators are represented as complex vectors and matrices. We provide a number of convenient ways to construct these objects. We also provide some tools for working with these objects, such as embedding operators in larger Hilbert spaces and selecting subspace indices."},{"id":14,"pagetitle":"Quantum Objects","title":"Quantum states","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Quantum-states","content":" Quantum states We can construct quantum states from bitstrings or string representations. The string representations use atomic notation (ground state  g , excited state  e , etc.). Ground state in a 2-level system. ket_from_string(\"g\", [2]) 2-element Vector{ComplexF64}:\n 1.0 + 0.0im\n 0.0 + 0.0im Superposition state coupled to a ground state in two 2-level systems. ket_from_string(\"(g+e)g\", [2,2]) 4-element Vector{ComplexF64}:\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im |01⟩  in a 2-qubit system. ket_from_bitstring(\"01\") 4-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im"},{"id":15,"pagetitle":"Quantum Objects","title":"Quantum operators","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Quantum-operators","content":" Quantum operators Frequently used operators are provided in  PAULIS  and  GATES ."},{"id":16,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.Gates.GATES","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.Gates.GATES-generated-quantum_objects","content":" PiccoloQuantumObjects.Gates.GATES  —  Constant A constant dictionary  GATES  containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix. GATES[:I]  - Identity: Leaves the state unchanged. GATES[:X]  - Pauli-X (NOT): Flips the qubit state. GATES[:Y]  - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere. GATES[:Z]  - Pauli-Z: Flips the phase of the qubit state. GATES[:H]  - Hadamard: Creates superposition by transforming basis states. GATES[:CX]  - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1⟩. GATES[:CZ]  - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1⟩. GATES[:XI]  - Complex: A gate for complex operations. GATES[:sqrtiSWAP]  - Square root of iSWAP: Partially swaps two qubits with a phase. source Quantum operators can also be constructed from strings. operator_from_string(\"X\") 2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im operator_from_string(\"XZ\") 4×4 Matrix{ComplexF64}:\n 0.0+0.0im   0.0+0.0im  1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -0.0+0.0im  0.0+0.0im  -1.0+0.0im\n 1.0+0.0im   0.0+0.0im  0.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im  0.0+0.0im  -0.0+0.0im Annihilation and creation operators are provided for oscillator systems. a = annihilate(3) 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im      0.0+0.0im\n 0.0+0.0im  0.0+0.0im  1.41421+0.0im\n 0.0+0.0im  0.0+0.0im      0.0+0.0im a⁺ = create(3) 3×3 Matrix{ComplexF64}:\n 0.0-0.0im      0.0-0.0im  0.0-0.0im\n 1.0-0.0im      0.0-0.0im  0.0-0.0im\n 0.0-0.0im  1.41421-0.0im  0.0-0.0im a'a 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  1.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  2.0+0.0im"},{"id":17,"pagetitle":"Quantum Objects","title":"Random operators","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Random-operators","content":" Random operators The  haar_random  function draws random unitary operators according to the Haar measure. haar_random(3) 3×3 Matrix{ComplexF64}:\n   0.322532+0.417251im  0.0934113+0.432683im   -0.0488445+0.723567im\n -0.0170277+0.186577im    0.73275-0.500004im    -0.414894+0.0763901im\n  -0.790534+0.248657im   0.110747-0.0697756im    0.473358+0.268375im If we want to generate random operations that are close to the identity, we can use the  haar_identity  function. haar_identity(2, 0.1) 2×2 Matrix{ComplexF64}:\n 0.991421-0.00439175im  -0.130514-0.00552259im\n 0.130615-0.00203104im    0.99095+0.030898im A smaller radius means the random operator is closer to the identity. haar_identity(2, 0.01) 2×2 Matrix{ComplexF64}:\n     0.999998+0.00202651im  0.000189584+9.40408e-6im\n -0.000189617+8.70744e-6im     0.999999+0.00164773im"},{"id":18,"pagetitle":"Quantum Objects","title":"Embedded operators","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Embedded-operators","content":" Embedded operators Sometimes we want to embed a quantum operator into a larger Hilbert space,  $\\mathcal{H}$ , which we decompose into subspace and leakage components: \\[    \\mathcal{H} = \\mathcal{H}_{\\text{subspace}} \\oplus \\mathcal{H}_{\\text{leakage}},\\] In quantum computing, the computation is encoded in a  subspace , while the remaining  leakage  states should be avoided."},{"id":19,"pagetitle":"Quantum Objects","title":"The embed and unembed functions","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#The-embed-and-unembed-functions","content":" The  embed  and  unembed  functions The  embed  function allows to embed a quantum operator in a larger Hilbert space."},{"id":20,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.embed-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Function embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int) Embed an  operator  in the  subspace  of a larger matrix of size  levels x levels . source embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator) Embed the  subspace_operator  in the subspace of a larger  embedded_operator . source The  unembed  function allows to unembed a quantum operator from a larger Hilbert space."},{"id":21,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.unembed-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Function unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}) Unembed a subspace operator from the  matrix . This is equivalent to calling   matrix[subspace, subspace] . source unembed(embedded_op::EmbeddedOperator)::Matrix{ComplexF64} Unembed an embedded operator, returning the original operator. source unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator) Unembed a sub-matrix from the  op  at the subspace defined by  embedded_op . source Embed a two-level X gate into a multilevel system. levels = 3\nX = GATES[:X]\nsubspace_indices = 1:2\nX_embedded = embed(X, subspace_indices, levels) 3×3 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im  0.0+0.0im\n 1.0+0.0im  0.0+0.0im  0.0+0.0im\n 0.0+0.0im  0.0+0.0im  0.0+0.0im Unembed to retrieve the original operator. X_original = unembed(X_embedded, subspace_indices) 2×2 Matrix{ComplexF64}:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im"},{"id":22,"pagetitle":"Quantum Objects","title":"The EmbeddedOperator type","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#The-EmbeddedOperator-type","content":" The  EmbeddedOperator  type The  EmbeddedOperator  type stores information about an operator embedded in the subspace of a larger quantum system."},{"id":23,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Type EmbeddedOperator Embedded operator type to represent an operator embedded in a subspace of a larger  quantum system. Fields operator::Matrix{ComplexF64} : Embedded operator of size     prod(subsystem_levels) x prod(subsystem_levels) . subspace::Vector{Int} : Indices of the subspace the operator is embedded in. subsystem_levels::Vector{Int} : Levels of the subsystems in the composite system. source We construct an embedded operator in the same manner as the  embed  function."},{"id":24,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{Matrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int}) Create an embedded operator. The  operator  is embedded at the  subspace  of the system spanned by the  subsystem_levels . source Embed an X gate in the first qubit's subspace within two 3-level systems. gate = GATES[:X] ⊗ GATES[:I]\nsubsystem_levels = [3, 3]\nsubspace_indices = get_subspace_indices([1:2, 1:2], subsystem_levels)\nembedded_operator = EmbeddedOperator(gate, subspace_indices, subsystem_levels) EmbeddedOperator(ComplexF64[0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; … ; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im … 0.0 + 0.0im 0.0 + 0.0im], [1, 2, 4, 5], [3, 3]) Show the full operator. embedded_operator.operator .|> real |> sparse 9×9 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅  Get the original operator back. unembed(embedded_operator) .|> real |> sparse 4×4 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:\n  ⋅    ⋅   1.0   ⋅ \n  ⋅    ⋅    ⋅   1.0\n 1.0   ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅  Embedded operators for composite systems are also supported."},{"id":25,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system, where  the  subsystem_indices  list the subspaces at which the operator is defined, and the  subsystem_levels  list the levels of the subsystems in which the operator is embedded.  source This is a two step process. The provided subspace operator is  lift -ed  from the  subsystem_indices  where  it is defined into the space spanned by the composite system's  subspaces . The lifted operator is embedded into the full Hilbert space spanned by the   subsystem_levels . Embed a CZ gate with control qubit 1 and target qubit 3 into a composite system made up of three 3-level systems. An identity is performed on qubit 2. subsystem_levels = [3, 3, 3]\nsubspaces = [1:2, 1:2, 1:2]\nembedded_operator = EmbeddedOperator(GATES[:CZ], [1, 3], subspaces, subsystem_levels)\nunembed(embedded_operator) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅   1.0   ⋅    ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅     ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0    ⋅    ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   -1.0   ⋅     ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅     ⋅   1.0    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅     ⋅    ⋅   -1.0"},{"id":26,"pagetitle":"Quantum Objects","title":"Subspace and leakage indices","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Subspace-and-leakage-indices","content":" Subspace and leakage indices"},{"id":27,"pagetitle":"Quantum Objects","title":"The get_subspace_indices function","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#The-get_subspace_indices-function","content":" The  get_subspace_indices  function The  get_subspace_indices  function is a convenient way to get the indices of a subspace in a larger quantum system."},{"id":28,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices  —  Function get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)    \nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator) Get the indices for the provided subspace of the quantum system. source Its dual function is  get_leakage_indices . get_subspace_indices(1:2, 5) |> collect, get_leakage_indices(1:2, 5) |> collect ([1, 2], [3, 4, 5]) Composite systems are supported. Get the indices of the two-qubit subspace within two 3-level systems. get_subspace_indices([1:2, 1:2], [3, 3]) 4-element Vector{Int64}:\n 1\n 2\n 4\n 5 Qubits are assumed if the indices are not provided. get_subspace_indices([3, 3]) 4-element Vector{Int64}:\n 1\n 2\n 4\n 5 get_leakage_indices([3, 3]) 5-element Vector{Int64}:\n 3\n 6\n 7\n 8\n 9"},{"id":29,"pagetitle":"Quantum Objects","title":"Excitation number restrictions","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#Excitation-number-restrictions","content":" Excitation number restrictions Sometimes we want to cap the number of excitations we allow across a composite system. For example, if we want to restrict ourselves to the ground and single excitation states of two 3-level systems: get_enr_subspace_indices(1, [3, 3]) 3-element Vector{Int64}:\n 1\n 2\n 4"},{"id":30,"pagetitle":"Quantum Objects","title":"The get_iso_vec_subspace_indices function","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#The-get_iso_vec_subspace_indices-function","content":" The  get_iso_vec_subspace_indices  function For isomorphic operators, the  get_iso_vec_subspace_indices  function can be used to find the appropriate vector indices of the equivalent operator subspace. See also,  Isomorphisms#Quantum-operator-isomorphisms ."},{"id":31,"pagetitle":"Quantum Objects","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","ref":"/PiccoloQuantumObjects/stable/generated/quantum_objects/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices-generated-quantum_objects","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices  —  Function get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator) Get the indices for the subspace in the isomorphic vector space for operators. source Its dual function is  get_iso_vec_leakage_indices , which by default only returns the leakage indices of the blocks: \\[\\mathcal{H}_{\\text{subspace}} \\otimes \\mathcal{H}_{\\text{subspace}},\\quad\n\\mathcal{H}_{\\text{subspace}} \\otimes \\mathcal{H}_{\\text{leakage}},\\quad\n\\mathcal{H}_{\\text{leakage}} \\otimes \\mathcal{H}_{\\text{subspace}}\\] allowing for leakage-suppressing code to disregard the uncoupled pure-leakage space. get_iso_vec_subspace_indices(1:2, 3) 8-element Vector{Int64}:\n  1\n  2\n  4\n  5\n  7\n  8\n 10\n 11 without_pure_leakage = get_iso_vec_leakage_indices(1:2, 3) 8-element Vector{Int64}:\n  3\n  6\n  9\n 12\n 13\n 14\n 16\n 17 Show the pure-leakage indices. with_pure_leakage = get_iso_vec_leakage_indices(1:2, 3, ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage) 2-element Vector{Int64}:\n 15\n 18 The pure-leakage indices can grow quickly! without_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4])\nwith_pure_leakage = get_iso_vec_leakage_indices([1:2, 1:2], [4, 4], ignore_pure_leakage=false)\nsetdiff(with_pure_leakage, without_pure_leakage) |> length 288 This page was generated using  Literate.jl ."},{"id":34,"pagetitle":"Quantum Systems","title":"Abstract Quantum Systems","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#Abstract-Quantum-Systems","content":" Abstract Quantum Systems using PiccoloQuantumObjects\nusing SparseArrays # for visualization\n⊗ = kron;"},{"id":35,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem  —  Type AbstractQuantumSystem Abstract type for defining systems. source"},{"id":36,"pagetitle":"Quantum Systems","title":"Quantum Systems","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#Quantum-Systems","content":" Quantum Systems The  QuantumSystem  type is used to represent a quantum system with a drift Hamiltonian and a set of drive Hamiltonians, \\[H = H_{\\text{drift}} + \\sum_i a_i H_{\\text{drives}}^{(i)}\\]"},{"id":37,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.QuantumSystem  —  Type QuantumSystem(H_drift::Matrix{<:Number}, H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H::Function, n_drives::Int; kwargs...) Constructs a  QuantumSystem  object from the drift and drive Hamiltonian terms. source QuantumSystem 's are containers for quantum dynamics. Internally, they compute the necessary isomorphisms to perform the dynamics in a real vector space. H_drift = PAULIS[:Z]\nH_drives = [PAULIS[:X], PAULIS[:Y]]\nsystem = QuantumSystem(H_drift, H_drives)\n\na_drives = [1, 0]\nsystem.H(a_drives) 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 1.0+0.0im   1.0+0.0im\n 1.0+0.0im  -1.0+0.0im To extract the drift and drive Hamiltonians from a  QuantumSystem , use the  get_drift  and  get_drives  functions. get_drift(system) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n 1.0+0.0im       ⋅    \n     ⋅      -1.0+0.0im Get the X drive. drives = get_drives(system)\ndrives[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅     And the Y drive. drives[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      0.0-1.0im\n 0.0+1.0im      ⋅     Note We can also construct a  QuantumSystem  directly from a Hamiltonian function. Internally,  ForwardDiff.jl  is used to compute the drives. H(a) = PAULIS[:Z] + a[1] * PAULIS[:X] + a[2] * PAULIS[:Y]\nsystem = QuantumSystem(H, 2)\nget_drives(system)[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n     ⋅      1.0+0.0im\n 1.0+0.0im      ⋅     Create a noise model with a confusion matrix. function H(a; C::Matrix{Float64}=[1.0 0.0; 0.0 1.0])\n    b = C * a\n    return b[1] * PAULIS.X + b[2] * PAULIS.Y\nend\n\nsystem = QuantumSystem(a -> H(a, C=[0.99 0.01; -0.01 1.01]), 2)\nconfused_drives = get_drives(system)\nconfused_drives[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n      ⋅       0.99+0.01im\n 0.99-0.01im       ⋅     confused_drives[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 2 stored entries:\n      ⋅       0.01-1.01im\n 0.01+1.01im       ⋅    "},{"id":38,"pagetitle":"Quantum Systems","title":"Open quantum systems","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#Open-quantum-systems","content":" Open quantum systems We can also construct an  OpenQuantumSystem  with Lindblad dynamics, enabling a user to pass a list of dissipation operators."},{"id":39,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem  —  Type OpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::AbstractVector{<:AbstractMatrix{<:Number}}\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}};\n    kwargs...\n)\nOpenQuantumSystem(\n    H_drift::Matrix{<:Number}, H_drives::AbstractVector{Matrix{<:Number}}; \n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[], \n    kwargs...\n)\nOpenQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nOpenQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nOpenQuantumSystem(H::Function, n_drives::Int; kwargs...) Constructs an  OpenQuantumSystem  object from the drift and drive Hamiltonian terms and dissipation operators. source Add a dephasing and annihilation error channel. H_drives = [PAULIS[:X]]\na = annihilate(2)\ndissipation_operators = [a'a, a]\nsystem = OpenQuantumSystem(H_drives, dissipation_operators=dissipation_operators)\nsystem.dissipation_operators[1] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 1 stored entry:\n     ⋅          ⋅    \n     ⋅      1.0+0.0im system.dissipation_operators[2] |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 1 stored entry:\n     ⋅      1.0+0.0im\n     ⋅          ⋅     Warning The Hamiltonian part  system.H  excludes the Lindblad operators. This is also true for functions that report properties of  system.H , such as  get_drift ,  get_drives , and  is_reachable . get_drift(system) |> sparse 2×2 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 0 stored entries:\n     ⋅          ⋅    \n     ⋅          ⋅    "},{"id":40,"pagetitle":"Quantum Systems","title":"Composite quantum systems","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#Composite-quantum-systems","content":" Composite quantum systems A  CompositeQuantumSystem  is constructed from a list of subsystems and their interactions. The interaction, in the form of drift or drive Hamiltonian, acts on the full Hilbert space. The subsystems, with their own drift and drive Hamiltonians, are internally lifted to the full Hilbert space. system_1 = QuantumSystem([PAULIS[:X]])\nsystem_2 = QuantumSystem([PAULIS[:Y]])\nH_drift = PAULIS[:Z] ⊗ PAULIS[:Z]\nsystem = CompositeQuantumSystem(H_drift, [system_1, system_2]); The drift Hamiltonian is the ZZ coupling. get_drift(system) |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n 1.0+0.0im       ⋅           ⋅          ⋅    \n     ⋅      -1.0+0.0im       ⋅          ⋅    \n     ⋅           ⋅      -1.0+0.0im      ⋅    \n     ⋅           ⋅           ⋅      1.0+0.0im The drives are the X and Y operators on the first and second subsystems. drives = get_drives(system)\ndrives[1] |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n     ⋅          ⋅      1.0+0.0im      ⋅    \n     ⋅          ⋅          ⋅      1.0+0.0im\n 1.0+0.0im      ⋅          ⋅          ⋅    \n     ⋅      1.0+0.0im      ⋅          ⋅     drives[2] |> sparse 4×4 SparseArrays.SparseMatrixCSC{ComplexF64, Int64} with 4 stored entries:\n     ⋅      0.0-1.0im      ⋅          ⋅    \n 0.0+1.0im      ⋅          ⋅          ⋅    \n     ⋅          ⋅          ⋅      0.0-1.0im\n     ⋅          ⋅      0.0+1.0im      ⋅    "},{"id":41,"pagetitle":"Quantum Systems","title":"The lift function","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#The-lift-function","content":" The  lift  function To lift operators acting on a subsystem into the full Hilbert space, use  lift ."},{"id":42,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.CompositeQuantumSystems.lift","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#PiccoloQuantumObjects.CompositeQuantumSystems.lift-generated-quantum_systems","content":" PiccoloQuantumObjects.CompositeQuantumSystems.lift  —  Function lift(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...) Lift an  operator  acting on the  i -th subsystem within  subsystem_levels  to an operator acting on the entire system spanning  subsystem_levels . source Create an  a + a'  operator acting on the 1st subsystem of a qutrit and qubit system. subspace_levels = [3, 2]\nlift(create(3) + annihilate(3), 1, subspace_levels) .|> real |> sparse 6×6 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n  ⋅    ⋅   1.0       ⋅        ⋅        ⋅ \n  ⋅    ⋅    ⋅       1.0       ⋅        ⋅ \n 1.0   ⋅    ⋅        ⋅       1.41421   ⋅ \n  ⋅   1.0   ⋅        ⋅        ⋅       1.41421\n  ⋅    ⋅   1.41421   ⋅        ⋅        ⋅ \n  ⋅    ⋅    ⋅       1.41421   ⋅        ⋅  Create IXI operator on the 2nd qubit in a 3-qubit system. lift(PAULIS[:X], 2, 3) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅  Create an XX operator acting on qubits 3 and 4 in a 4-qubit system. lift([PAULIS[:X], PAULIS[:X]], [3, 4], 4) .|> real |> sparse 16×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:\n⎡⡠⠊⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⡠⠊⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⡠⠊⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⡠⠊⎦ We can also lift an operator that entangles different subspaces by passing the indices of the entangled subsystems. #_Here's another way to create an XX operator acting on qubits 3 and 4 in a 4-qubit system._\nlift(kron(PAULIS[:X], PAULIS[:X]), [3, 4], 4) .|> real |> sparse 16×16 SparseArrays.SparseMatrixCSC{Float64, Int64} with 16 stored entries:\n⎡⡠⠊⠀⠀⠀⠀⠀⠀⎤\n⎢⠀⠀⡠⠊⠀⠀⠀⠀⎥\n⎢⠀⠀⠀⠀⡠⠊⠀⠀⎥\n⎣⠀⠀⠀⠀⠀⠀⡠⠊⎦ Lift a CX gate acting on the 1st and 3rd qubits in a 3-qubit system. The result is independent of the state of the second qubit. lift(GATES[:CX], [1, 3], 3) .|> real |> sparse 8×8 SparseArrays.SparseMatrixCSC{Float64, Int64} with 8 stored entries:\n 1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅   1.0   ⋅    ⋅    ⋅ \n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0\n  ⋅    ⋅    ⋅    ⋅    ⋅    ⋅   1.0   ⋅ "},{"id":43,"pagetitle":"Quantum Systems","title":"Reachability tests","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#Reachability-tests","content":" Reachability tests Whether a quantum system can be used to reach a target state or operator can be tested by computing the dynamical Lie algebra. Access to this calculation is provided by the  is_reachable  function."},{"id":44,"pagetitle":"Quantum Systems","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/stable/generated/quantum_systems/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-generated-quantum_systems","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Function is_reachable(gate, hamiltonians; kwargs...) Check if the  gate  is reachable using the given  hamiltonians . Arguments gate::AbstractMatrix : target gate hamiltonians::AbstractVector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments subspace::AbstractVector{<:Int}=1:size(gate, 1) : subspace indices compute_basis::Bool=true : compute the basis or use the Hamiltonians directly remove_trace::Bool=true : remove trace from generators verbose::Bool=true : print information about the operator algebra atol::Float32=eps(Float32) : absolute tolerance See also  QuantumSystemUtils.operator_algebra . source is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...) Check if the  gate  is reachable using the given  system . Keyword Arguments use_drift::Bool=true : include drift Hamiltonian in the generators kwargs... : keyword arguments for  is_reachable source Y can be reached by commuting Z and X. system = QuantumSystem(PAULIS[:Z], [PAULIS[:X]])\nis_reachable(PAULIS[:Y], system) true Y cannot be reached by X alone. system = QuantumSystem([PAULIS[:X]])\nis_reachable(PAULIS[:Y], system) false This page was generated using  Literate.jl ."},{"id":47,"pagetitle":"Library","title":"Quantum Systems","ref":"/PiccoloQuantumObjects/stable/lib/#Quantum-Systems","content":" Quantum Systems"},{"id":48,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.AbstractQuantumSystem  —  Type AbstractQuantumSystem Abstract type for defining systems. source"},{"id":49,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.OpenQuantumSystem  —  Type OpenQuantumSystem(\n    H_drift::AbstractMatrix{<:Number},\n    H_drives::AbstractVector{<:AbstractMatrix{<:Number}}\n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}};\n    kwargs...\n)\nOpenQuantumSystem(\n    H_drift::Matrix{<:Number}, H_drives::AbstractVector{Matrix{<:Number}}; \n    dissipation_operators::AbstractVector{<:AbstractMatrix{<:Number}}=Matrix{ComplexF64}[], \n    kwargs...\n)\nOpenQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nOpenQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nOpenQuantumSystem(H::Function, n_drives::Int; kwargs...) Constructs an  OpenQuantumSystem  object from the drift and drive Hamiltonian terms and dissipation operators. source"},{"id":50,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.QuantumSystem","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystems.QuantumSystem","content":" PiccoloQuantumObjects.QuantumSystems.QuantumSystem  —  Type QuantumSystem(H_drift::Matrix{<:Number}, H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H_drift::Matrix{<:Number}; kwargs...)\nQuantumSystem(H_drives::Vector{Matrix{<:Number}}; kwargs...)\nQuantumSystem(H::Function, n_drives::Int; kwargs...) Constructs a  QuantumSystem  object from the drift and drive Hamiltonian terms. source"},{"id":51,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drift","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystems.get_drift-Tuple{AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystems.get_drift  —  Method get_drift(sys::AbstractQuantumSystem) Returns the drift Hamiltonian of the system. source"},{"id":52,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystems.get_drives","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystems.get_drives-Tuple{AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystems.get_drives  —  Method get_drives(sys::AbstractQuantumSystem) Returns the drive Hamiltonians of the system. source"},{"id":53,"pagetitle":"Library","title":"Composite Quantum Systems","ref":"/PiccoloQuantumObjects/stable/lib/#Composite-Quantum-Systems","content":" Composite Quantum Systems"},{"id":54,"pagetitle":"Library","title":"PiccoloQuantumObjects.CompositeQuantumSystems.CompositeQuantumSystem","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.CompositeQuantumSystems.CompositeQuantumSystem","content":" PiccoloQuantumObjects.CompositeQuantumSystems.CompositeQuantumSystem  —  Type CompositeQuantumSystem <: AbstractQuantumSystem A composite quantum system consisting of  subsystems . Couplings between subsystems can be additionally defined. Subsystem drives are always appended to any new coupling drives. source"},{"id":55,"pagetitle":"Library","title":"PiccoloQuantumObjects.CompositeQuantumSystems.lift","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.CompositeQuantumSystems.lift","content":" PiccoloQuantumObjects.CompositeQuantumSystems.lift  —  Function lift(operator::AbstractMatrix{<:Number}, i::Int, subsystem_levels::Vector{Int})\nlift(operator::AbstractMatrix{<:Number}, i::Int, n_qubits::Int; kwargs...)\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, subsystem_levels::Vector{Int})\nlift(operators::AbstractVector{<:AbstractMatrix{T}}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...)\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nlift(operator::AbstractMatrix{T}, indices::AbstractVector{Int}, n_qubits::Int; kwargs...) Lift an  operator  acting on the  i -th subsystem within  subsystem_levels  to an operator acting on the entire system spanning  subsystem_levels . source"},{"id":56,"pagetitle":"Library","title":"Gates","ref":"/PiccoloQuantumObjects/stable/lib/#Gates","content":" Gates"},{"id":57,"pagetitle":"Library","title":"PiccoloQuantumObjects.Gates.GATES","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Gates.GATES","content":" PiccoloQuantumObjects.Gates.GATES  —  Constant A constant dictionary  GATES  containing common quantum gate matrices as complex-valued matrices. Each gate is represented by its unitary matrix. GATES[:I]  - Identity: Leaves the state unchanged. GATES[:X]  - Pauli-X (NOT): Flips the qubit state. GATES[:Y]  - Pauli-Y: Rotates the qubit state around the Y-axis of the Bloch sphere. GATES[:Z]  - Pauli-Z: Flips the phase of the qubit state. GATES[:H]  - Hadamard: Creates superposition by transforming basis states. GATES[:CX]  - Controlled-X (CNOT): Flips the 2nd qubit (target) if the first qubit (control) is |1⟩. GATES[:CZ]  - Controlled-Z (CZ): Flips the phase of the 2nd qubit (target) if the 1st qubit (control) is |1⟩. GATES[:XI]  - Complex: A gate for complex operations. GATES[:sqrtiSWAP]  - Square root of iSWAP: Partially swaps two qubits with a phase. source"},{"id":58,"pagetitle":"Library","title":"PiccoloQuantumObjects.Gates.PAULIS","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Gates.PAULIS","content":" PiccoloQuantumObjects.Gates.PAULIS  —  Constant The 2×2 Pauli matrics and identity. source"},{"id":59,"pagetitle":"Library","title":"Embedded Operators","ref":"/PiccoloQuantumObjects/stable/lib/#Embedded-Operators","content":" Embedded Operators"},{"id":60,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator","content":" PiccoloQuantumObjects.EmbeddedOperators.AbstractPiccoloOperator  —  Type AbstractPiccoloOperator Union type for operators. source"},{"id":61,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Type EmbeddedOperator Embedded operator type to represent an operator embedded in a subspace of a larger  quantum system. Fields operator::Matrix{ComplexF64} : Embedded operator of size     prod(subsystem_levels) x prod(subsystem_levels) . subspace::Vector{Int} : Indices of the subspace the operator is embedded in. subsystem_levels::Vector{Int} : Levels of the subsystems in the composite system. source"},{"id":62,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    subsystem_levels::AbstractVector{Int}\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system, where  the  subsystem_indices  list the subspaces at which the operator is defined, and the  subsystem_levels  list the levels of the subsystems in which the operator is embedded.  source"},{"id":63,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{<:AbstractVector{Int64}}, CompositeQuantumSystem}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(\n    subspace_operator::AbstractMatrix{<:Number},\n    subsystem_indices::AbstractVector{Int},\n    subspaces::AbstractVector{<:AbstractVector{Int}},\n    composite_system::CompositeQuantumSystem\n) Embed the  subspace_operator  into the provided  subspaces  of a composite system. source"},{"id":64,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::Matrix{<:Number}, subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int}) Create an embedded operator. The  operator  is embedded at the  subspace  of the system spanned by the  subsystem_levels . source"},{"id":65,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator-Tuple{AbstractMatrix{<:Number}, QuantumSystem}","content":" PiccoloQuantumObjects.EmbeddedOperators.EmbeddedOperator  —  Method EmbeddedOperator(subspace_operator::AbstractMatrix{<:Number}, system::QuantumSystem; kwargs...) Embed the  subspace_operator  into a quantum  system . source"},{"id":66,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Method embed(subspace_operator::AbstractMatrix{<:Number}, embedded_operator::EmbeddedOperator) Embed the  subspace_operator  in the subspace of a larger  embedded_operator . source"},{"id":67,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.embed","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.embed-Union{Tuple{R}, Tuple{AbstractMatrix{R}, AbstractVector{Int64}, Int64}} where R<:Number","content":" PiccoloQuantumObjects.EmbeddedOperators.embed  —  Method embed(operator::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}, levels::Int) Embed an  operator  in the  subspace  of a larger matrix of size  levels x levels . source"},{"id":68,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices-Tuple{Int64, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.get_enr_subspace_indices  —  Method get_enr_subspace_indices(excitation_restriction::Int, subsystem_levels::AbstractVector{Int}) Get the indices for the subspace of the quantum system with an excitation restriction. source"},{"id":69,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_leakage_indices  —  Function get_iso_vec_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_iso_vec_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_iso_vec_leakage_indices(op::EmbeddedOperator) Get the indices for the leakage in the isomorphic vector space for operators. source"},{"id":70,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_iso_vec_subspace_indices  —  Function get_iso_vec_subspace_indices(subspace::AbstractVector{Int}, subsystem_levels::AbstractVector{Int})\nget_iso_vec_subspace_indices(op::EmbeddedOperator) Get the indices for the subspace in the isomorphic vector space for operators. source"},{"id":71,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_leakage_indices  —  Function get_leakage_indices(subspace::AbstractVector{Int}, levels::Int)\nget_leakage_indices(subspaces::AbstractVector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_leakage_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_leakage_indices(op::EmbeddedOperator) Get the indices for the states that are outside of the provided subspace of the quantum system. source"},{"id":72,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices","content":" PiccoloQuantumObjects.EmbeddedOperators.get_subspace_indices  —  Function get_subspace_indices(subspace::AbstractVector{Int}, levels::Int)    \nget_subspace_indices(subspaces::Vector{<:AbstractVector{Int}}, subsystem_levels::AbstractVector{Int})\nget_subspace_indices(subsystem_levels::AbstractVector{Int}; subspace=1:2)\nget_subspace_indices(op::EmbeddedOperator) Get the indices for the provided subspace of the quantum system. source"},{"id":73,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, AbstractVector{Int64}}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(matrix::AbstractMatrix{<:Number}, subspace::AbstractVector{Int}) Unembed a subspace operator from the  matrix . This is equivalent to calling   matrix[subspace, subspace] . source"},{"id":74,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{AbstractMatrix{<:Number}, EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(op::AbstractMatrix, embedded_op::EmbeddedOperator) Unembed a sub-matrix from the  op  at the subspace defined by  embedded_op . source"},{"id":75,"pagetitle":"Library","title":"PiccoloQuantumObjects.EmbeddedOperators.unembed","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.EmbeddedOperators.unembed-Tuple{EmbeddedOperator}","content":" PiccoloQuantumObjects.EmbeddedOperators.unembed  —  Method unembed(embedded_op::EmbeddedOperator)::Matrix{ComplexF64} Unembed an embedded operator, returning the original operator. source"},{"id":76,"pagetitle":"Library","title":"Isomorphisims","ref":"/PiccoloQuantumObjects/stable/lib/#Isomorphisims","content":" Isomorphisims"},{"id":77,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.G","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.G-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.G  —  Method G(H::AbstractMatrix)::Matrix{Float64} Returns the isomorphism of  $-iH$ , i.e.  $G(H) = \\text{iso}(-iH)$ . See also  Isomorphisms.iso ,  Isomorphisms.H . source"},{"id":78,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.H","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.H-Tuple{AbstractMatrix{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.H  —  Method H(G::AbstractMatrix{<:Real}) Returns the inverse of  $G(H) = iso(-iH)$ , i.e. returns H. See also  Isomorphisms.iso ,  Isomorphisms.G . source"},{"id":79,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ad_vec","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.ad_vec-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.ad_vec  —  Method ad_vec(H::AbstractMatrix{ℂ}; anti::Bool=false) where ℂ <: Number Returns the vectorized adjoint action of a matrix  H : \\[\\text{ad_vec}(H) = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes H - (-1)^{\\text{anti}} \\mqty(0 & 1 \\\\ 1 & 0) \\otimes H^*\\] source"},{"id":80,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.density_to_iso_vec  —  Method density_to_iso_vec(ρ::AbstractMatrix{<:Number}) Returns the isomorphism  ρ⃗̃ = ket_to_iso(vec(ρ))  of a density matrix  ρ source"},{"id":81,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso-Tuple{AbstractMatrix{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.iso  —  Method iso(H::AbstractMatrix{<:Number}) Returns the isomorphism of  $H$ : \\[iso(H) = \\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] where  $\\Im(H)$  and  $\\Re(H)$  are the imaginary and real parts of  $H$  and the tilde  indicates the standard isomorphism of a complex valued matrix: \\[\\widetilde{H} = \\mqty(1 & 0 \\\\ 0 & 1) \\otimes \\Re(H) + \\mqty(0 & -1 \\\\ 1 & 0) \\otimes \\Im(H)\\] See also  Isomorphisms.G ,  Isomorphisms.H . source"},{"id":82,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_D","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_D-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.iso_D  —  Method iso_D(L::AbstractMatrix{ℂ}) where ℂ <: Number Returns the isomorphic representation of the Lindblad dissipator  L . source"},{"id":83,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec-Union{Tuple{AbstractMatrix{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_operator_to_iso_vec  —  Method iso_operator_to_iso_vec(Ũ::AbstractMatrix{ℝ}) where ℝ <: Real Convert a real matrix  Ũ  representing an isomorphism operator into a real vector. source"},{"id":84,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator-Tuple{Any}","content":" PiccoloQuantumObjects.Isomorphisms.iso_operator_to_operator  —  Method iso_operator_to_operator(Ũ) source"},{"id":85,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_to_ket","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_to_ket-Tuple{AbstractVector{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.iso_to_ket  —  Method iso_to_ket(ψ̃::AbstractVector{<:Real}) Convert a real isomorphism vector  ψ̃  into a ket vector. source"},{"id":86,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density-Tuple{AbstractVector{<:Real}}","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_density  —  Method iso_vec_to_density(ρ⃗̃::AbstractVector{<:Real}) Returns the density matrix  ρ  from its isomorphism  ρ⃗̃ source"},{"id":87,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator-Union{Tuple{AbstractVector{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_iso_operator  —  Method iso_vec_to_iso_operator(Ũ⃗::AbstractVector{ℝ}) where ℝ <: Real Convert a real vector  Ũ⃗  into a real matrix representing an isomorphism operator. source"},{"id":88,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator-Union{Tuple{AbstractVector{ℝ}}, Tuple{ℝ}} where ℝ<:Real","content":" PiccoloQuantumObjects.Isomorphisms.iso_vec_to_operator  —  Method iso_vec_to_operator(Ũ⃗::AbstractVector{ℝ}) where ℝ <: Real Convert a real vector  Ũ⃗  into a complex matrix representing an operator. source"},{"id":89,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.ket_to_iso","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.ket_to_iso-Tuple{AbstractVector{<:Number}}","content":" PiccoloQuantumObjects.Isomorphisms.ket_to_iso  —  Method ket_to_iso(ψ::AbstractVector{<:Number}) Convert a ket vector  ψ  into a complex vector with real and imaginary parts. source"},{"id":90,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.mat","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.mat-Tuple{AbstractVector}","content":" PiccoloQuantumObjects.Isomorphisms.mat  —  Method mat(x::AbstractVector) Convert a vector  x  into a square matrix. The length of  x  must be a perfect square. source"},{"id":91,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator-Tuple{Any}","content":" PiccoloQuantumObjects.Isomorphisms.operator_to_iso_operator  —  Method operator_to_iso_operator(U) source"},{"id":92,"pagetitle":"Library","title":"PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec-Union{Tuple{AbstractMatrix{ℂ}}, Tuple{ℂ}} where ℂ<:Number","content":" PiccoloQuantumObjects.Isomorphisms.operator_to_iso_vec  —  Method operator_to_iso_vec(U::AbstractMatrix{ℂ}) where ℂ <: Number Convert a complex matrix  U  representing an operator into a real vector. source"},{"id":93,"pagetitle":"Library","title":"Quantum Object Utilities","ref":"/PiccoloQuantumObjects/stable/lib/#Quantum-Object-Utilities","content":" Quantum Object Utilities"},{"id":94,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.annihilate","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.annihilate-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.annihilate  —  Method annihilate(levels::Int) Get the annihilation operator for a system with  levels . source"},{"id":95,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.create","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.create-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.create  —  Method create(levels::Int) Get the creation operator for a system with  levels . source"},{"id":96,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_identity","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_identity-Tuple{Int64, Number}","content":" PiccoloQuantumObjects.QuantumObjectUtils.haar_identity  —  Method haar_identity(n::Int, radius::Number) Generate a random unitary matrix close to the identity matrix using the Haar measure for  an  n -dimensional system with a given  radius . The smaller the radius, the closer the matrix will be to the identity. source"},{"id":97,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.haar_random","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.haar_random-Tuple{Int64}","content":" PiccoloQuantumObjects.QuantumObjectUtils.haar_random  —  Method haar_random(n::Int) Generate a random unitary matrix using the Haar measure for an  n -dimensional system. source"},{"id":98,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring-Tuple{String}","content":" PiccoloQuantumObjects.QuantumObjectUtils.ket_from_bitstring  —  Method ket_from_bitstring(ket::String) Get the state vector for a qubit system given a ket string  ket  of 0s and 1s. source"},{"id":99,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string-Tuple{String, Vector{Int64}}","content":" PiccoloQuantumObjects.QuantumObjectUtils.ket_from_string  —  Method ket_from_string(\n    ket::String,\n    levels::Vector{Int};\n    level_dict=Dict(:g => 0, :e => 1, :f => 2, :h => 2),\n    return_states=false\n) Construct a quantum state from a string ket representation. source"},{"id":100,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string-Tuple{String}","content":" PiccoloQuantumObjects.QuantumObjectUtils.operator_from_string  —  Method operator_from_string(operator::String; lookup=PAULIS) Reduce the string (each character is one key) via operators from a dictionary. source"},{"id":101,"pagetitle":"Library","title":"Quantum System Utilities","ref":"/PiccoloQuantumObjects/stable/lib/#Quantum-System-Utilities","content":" Quantum System Utilities"},{"id":102,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractQuantumSystem}","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Method is_reachable(gate::AbstractMatrix{<:Number}, system::AbstractQuantumSystem; kwargs...) Check if the  gate  is reachable using the given  system . Keyword Arguments use_drift::Bool=true : include drift Hamiltonian in the generators kwargs... : keyword arguments for  is_reachable source"},{"id":103,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.is_reachable","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystemUtils.is_reachable-Tuple{AbstractMatrix{<:Number}, AbstractVector{<:AbstractMatrix{<:Number}}}","content":" PiccoloQuantumObjects.QuantumSystemUtils.is_reachable  —  Method is_reachable(gate, hamiltonians; kwargs...) Check if the  gate  is reachable using the given  hamiltonians . Arguments gate::AbstractMatrix : target gate hamiltonians::AbstractVector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments subspace::AbstractVector{<:Int}=1:size(gate, 1) : subspace indices compute_basis::Bool=true : compute the basis or use the Hamiltonians directly remove_trace::Bool=true : remove trace from generators verbose::Bool=true : print information about the operator algebra atol::Float32=eps(Float32) : absolute tolerance See also  QuantumSystemUtils.operator_algebra . source"},{"id":104,"pagetitle":"Library","title":"PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra","ref":"/PiccoloQuantumObjects/stable/lib/#PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra-Union{Tuple{Vector{<:AbstractMatrix{T}}}, Tuple{T}} where T<:Number","content":" PiccoloQuantumObjects.QuantumSystemUtils.operator_algebra  —  Method operator_algebra(generators; kwargs...) Compute the Lie algebra basis for the given  generators . Arguments generators::Vector{<:AbstractMatrix} : generators of the Lie algebra Keyword Arguments return_layers::Bool=false : return the Lie tree layers normalize::Bool=false : normalize the basis verbose::Bool=false : print information remove_trace::Bool=true : remove trace from generators source"},{"id":107,"pagetitle":"Home","title":"NamedTrajectories.jl","ref":"/NamedTrajectories/stable/#NamedTrajectories.jl","content":" NamedTrajectories.jl An elegant way to handle messy trajectory data Notice This package is under active development and issues may arise – please be patient and report any issues you find!  "},{"id":108,"pagetitle":"Home","title":"Motivation","ref":"/NamedTrajectories/stable/#Motivation","content":" Motivation NamedTrajectories.jl  is designed to aid in the messy indexing involved in solving trajectory optimization problems of the form \\[\\begin{align*}\n\\underset{u^1_{1:T}, \\dots, u^{n_c}_{1:T}}{\\underset{x^1_{1:T}, \\cdots, x^{n_s}_{1:T}}{\\operatorname{minimize}}} &\\quad J\\qty(x^{1:n_s}_{1:T},u^{1:n_c}_{1:T}) \\\\\n\\text{subject to} & \\quad f\\qty(x^{1:n_s}_{1:T},u^{1:n_c}_{1:T}) = 0 \\\\\n& \\quad x^i_1 = x^i_{\\text{initial}} \\\\\n& \\quad x^i_T = x^i_{\\text{final}} \\\\\n& \\quad u^i_1 = u^i_{\\text{initial}} \\\\\n& \\quad u^i_T = u^i_{\\text{final}} \\\\\n& \\quad x^i_{\\min} < x^i_t < x^i_{\\max} \\\\\n& \\quad u^i_{\\min} < u^i_t < u^i_{\\max} \\\\\n\\end{align*}\\] Where  $x^i_t$  is the  $i$ th state variable and  $u^i_t$  is the  $i$ th control variable at timestep  $t$ ; state and control variables can be of arbitrary dimension. The function  $f$  is a nonlinear constraint function and  $J$  is the objective function. These problems can have an arbitrary number of state ( $n_s$ ) and control ( $n_c$ ) variables, and the number of timesteps  $T$  can vary as well.   In trajectory optimization problems it is common practice to bundle all of the state and control variables together into a single  knot point \\[z_t = \\mqty(\n    x^1_t \\\\\n    \\vdots \\\\\n    x^{n_s}_t \\\\\n    u^1_t \\\\\n    \\vdots \\\\\n    u^{n_c}_t\n).\\] The trajectory optimization problem can then be succinctly written as \\[\\begin{align*}\n\\underset{z_{1:T}}{\\operatorname{minimize}} &\\quad J\\qty(z_{1:T}) \\\\\n\\text{subject to} & \\quad f\\qty(z_{1:T}) = 0 \\\\\n& \\quad z_1 = z_{\\text{initial}} \\\\\n& \\quad z_T = z_{\\text{final}} \\\\\n& \\quad z_{\\min} < z_t < z_{\\max} \\\\\n\\end{align*}\\] The  NamedTrajectories  package provides a  NamedTrajectory  type which abstracts away the messy indexing and vectorization details required for interfacing with numerical solvers.  It also provides a variety of helpful methods for common tasks.  For example, you can access the data by name or index.  In the case of an index, a  KnotPoint  is returned which contains the data for that timestep."},{"id":109,"pagetitle":"Home","title":"Features","ref":"/NamedTrajectories/stable/#Features","content":" Features Abstract away messy indexing and vectorization details required for interfacing with numerical solvers. Easily handle multiple trajectories with different names, e.g. various states and controls. Simple plotting of trajectories. Provide a variety of helpful methods for common tasks."},{"id":110,"pagetitle":"Home","title":"Index","ref":"/NamedTrajectories/stable/#Index","content":" Index NamedTrajectories.MethodsNamedTrajectory.add_component! NamedTrajectories.MethodsNamedTrajectory.get_component_names NamedTrajectories.MethodsNamedTrajectory.get_components NamedTrajectories.MethodsNamedTrajectory.get_duration NamedTrajectories.MethodsNamedTrajectory.get_times NamedTrajectories.MethodsNamedTrajectory.get_timesteps NamedTrajectories.MethodsNamedTrajectory.merge_outer NamedTrajectories.MethodsNamedTrajectory.remove_component NamedTrajectories.MethodsNamedTrajectory.remove_components NamedTrajectories.MethodsNamedTrajectory.update! NamedTrajectories.MethodsNamedTrajectory.update! NamedTrajectories.MethodsNamedTrajectory.update_bound! Base.:== Base.copy Base.getindex Base.getindex Base.getindex Base.getproperty Base.isequal Base.lastindex Base.length Base.merge Base.rand Base.setproperty! Base.size Base.vec"},{"id":113,"pagetitle":"Adding and removing variables","title":"Adding and removing variables","ref":"/NamedTrajectories/stable/generated/man/add_remove/#Adding-and-removing-variables","content":" Adding and removing variables This page was generated using  Literate.jl ."},{"id":116,"pagetitle":"Constructors","title":"Constructors","ref":"/NamedTrajectories/stable/generated/man/constructors/#Constructors","content":" Constructors To construct a  NamedTrajectory  using NamedTrajectories.jl, we simply need to utilize the  NamedTrajectory  constructor. using NamedTrajectories\n\n# define number of timesteps and timestep\nT = 10\ndt = 0.1 0.1 build named tuple of components and data matrices. components = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(dt, 1, T),\n) (x = [0.4961370332791444 0.23237820105313567 … 0.6844197715635315 0.6361929387686569; 0.008717346235256551 0.2636940050947565 … 0.2922208682028965 0.5956562698748092; 0.35652616846349006 0.0056948857589705915 … 0.19200473691928943 0.8329103228848768], u = [0.8294909770046149 0.08928178155816935 … 0.9911584036098497 0.0009350735740885074; 0.7421717979342167 0.08764582176322355 … 0.14236442296107765 0.020438567213176717], Δt = [0.1 0.1 … 0.1 0.1]) we must specify a timestep and control variable for the trajectory. timestep = 0.1\ncontrol = :u :u we can now create a  NamedTrajectory  object. traj = NamedTrajectory(components; timestep=timestep, controls=control) NamedTrajectory{Float64}([0.4961370332791444 0.23237820105313567 … 0.6844197715635315 0.6361929387686569; 0.008717346235256551 0.2636940050947565 … 0.2922208682028965 0.5956562698748092; … ; 0.7421717979342167 0.08764582176322355 … 0.14236442296107765 0.020438567213176717; 0.1 0.1 … 0.1 0.1], [0.4961370332791444, 0.008717346235256551, 0.35652616846349006, 0.8294909770046149, 0.7421717979342167, 0.1, 0.23237820105313567, 0.2636940050947565, 0.0056948857589705915, 0.08928178155816935  …  0.19200473691928943, 0.9911584036098497, 0.14236442296107765, 0.1, 0.6361929387686569, 0.5956562698748092, 0.8329103228848768, 0.0009350735740885074, 0.020438567213176717, 0.1], 10, 0.1, 6, (x = 3, u = 2, Δt = 1, states = 4, controls = 2), NamedTuple(), NamedTuple(), NamedTuple(), NamedTuple(), (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3, 6], controls = [4, 5]), NamedTuple(), 0, NamedTuple(), NamedTuple(), (:x, :u, :Δt), (:x, :Δt), (:u,)) Construct  NamedTrajectory  from previous constructed one. traj = NamedTrajectory(components, traj) NamedTrajectory{Float64}([0.4961370332791444 0.23237820105313567 … 0.6844197715635315 0.6361929387686569; 0.008717346235256551 0.2636940050947565 … 0.2922208682028965 0.5956562698748092; … ; 0.7421717979342167 0.08764582176322355 … 0.14236442296107765 0.020438567213176717; 0.1 0.1 … 0.1 0.1], [0.4961370332791444, 0.008717346235256551, 0.35652616846349006, 0.8294909770046149, 0.7421717979342167, 0.1, 0.23237820105313567, 0.2636940050947565, 0.0056948857589705915, 0.08928178155816935  …  0.19200473691928943, 0.9911584036098497, 0.14236442296107765, 0.1, 0.6361929387686569, 0.5956562698748092, 0.8329103228848768, 0.0009350735740885074, 0.020438567213176717, 0.1], 10, 0.1, 6, (x = 3, u = 2, Δt = 1, states = 4, controls = 2), NamedTuple(), NamedTuple(), NamedTuple(), NamedTuple(), (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3, 6], controls = [4, 5]), NamedTuple(), 0, NamedTuple(), NamedTuple(), (:x, :u, :Δt), (:x, :Δt), (:u,)) This page was generated using  Literate.jl ."},{"id":119,"pagetitle":"Copying and equality","title":"Copying and equality","ref":"/NamedTrajectories/stable/generated/man/copy_equality/#Copying-and-equality","content":" Copying and equality This page was generated using  Literate.jl ."},{"id":122,"pagetitle":"Operations with other trajectories","title":"Operations with other trajectories","ref":"/NamedTrajectories/stable/generated/man/operations/#Operations-with-other-trajectories","content":" Operations with other trajectories This page was generated using  Literate.jl ."},{"id":125,"pagetitle":"Add params in NamedTrajectory","title":"Add params in NamedTrajectory","ref":"/NamedTrajectories/stable/generated/man/params_in_struct/#Add-params-in-NamedTrajectory","content":" Add params in NamedTrajectory NamedTrajectory.jl support passing parameters as a Tuple when construct a  NamedTrajectory . using NamedTrajectories First we need to define number of timesteps and timestep T = 10\ndt = 0.1 0.1 then build named tuple of components and data matrices. components = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = fill(dt, 1, T),\n) (x = [0.3476620977699856 0.198619726446566 … 0.39803866393272225 0.6265174753283287; 0.8046466894423636 0.03134785864356637 … 0.8478921369175382 0.4884145755865088; 0.5666698416360124 0.13976133295517412 … 0.3868516834167772 0.46920304578004846], u = [0.1890540644490638 0.9565296024971514 … 0.9792809421326739 0.4172647591081198; 0.18425375127058363 0.9004171437218287 … 0.0957184688500965 0.9101760015037146], Δt = [0.1 0.1 … 0.1 0.1]) we must specify a timestep and control variable for the trajectory. timestep = 0.1\ncontrol = :u :u some global params as a NamedTuple params = (\n    α = rand(1),\n    β = rand(1)\n) (α = [0.8572905072360408], β = [0.6245809076559321]) we can now create a  NamedTrajectory  object with parameters specification. traj = NamedTrajectory(components; timestep=timestep, controls=control, global_data=params) NamedTrajectory{Float64}([0.3476620977699856 0.198619726446566 … 0.39803866393272225 0.6265174753283287; 0.8046466894423636 0.03134785864356637 … 0.8478921369175382 0.4884145755865088; … ; 0.18425375127058363 0.9004171437218287 … 0.0957184688500965 0.9101760015037146; 0.1 0.1 … 0.1 0.1], [0.3476620977699856, 0.8046466894423636, 0.5666698416360124, 0.1890540644490638, 0.18425375127058363, 0.1, 0.198619726446566, 0.03134785864356637, 0.13976133295517412, 0.9565296024971514  …  0.3868516834167772, 0.9792809421326739, 0.0957184688500965, 0.1, 0.6265174753283287, 0.4884145755865088, 0.46920304578004846, 0.4172647591081198, 0.9101760015037146, 0.1], 10, 0.1, 6, (x = 3, u = 2, Δt = 1, states = 4, controls = 2), NamedTuple(), NamedTuple(), NamedTuple(), NamedTuple(), (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3, 6], controls = [4, 5]), (α = [0.8572905072360408], β = [0.6245809076559321]), 2, (α = 1, β = 1), (α = 61:61, β = 62:62), (:x, :u, :Δt), (:x, :Δt), (:u,)) This page was generated using  Literate.jl ."},{"id":128,"pagetitle":"Retrieving data","title":"Retrieving data","ref":"/NamedTrajectories/stable/generated/man/retrieval/#Retrieving-data","content":" Retrieving data This page was generated using  Literate.jl ."},{"id":131,"pagetitle":"Times and timesteps","title":"Times and timesteps","ref":"/NamedTrajectories/stable/generated/man/times/#Times-and-timesteps","content":" Times and timesteps This page was generated using  Literate.jl ."},{"id":134,"pagetitle":"Updating data","title":"Updating data","ref":"/NamedTrajectories/stable/generated/man/updating/#Updating-data","content":" Updating data This page was generated using  Literate.jl ."},{"id":137,"pagetitle":"Manual","title":"Manual","ref":"/NamedTrajectories/stable/generated/manual/#Manual","content":" Manual"},{"id":138,"pagetitle":"Manual","title":"Constructors","ref":"/NamedTrajectories/stable/generated/manual/#Constructors","content":" Constructors"},{"id":139,"pagetitle":"Manual","title":"Retrieving data","ref":"/NamedTrajectories/stable/generated/manual/#Retrieving-data","content":" Retrieving data"},{"id":140,"pagetitle":"Manual","title":"Adding and removing variables","ref":"/NamedTrajectories/stable/generated/manual/#Adding-and-removing-variables","content":" Adding and removing variables"},{"id":141,"pagetitle":"Manual","title":"Updating data and bounds","ref":"/NamedTrajectories/stable/generated/manual/#Updating-data-and-bounds","content":" Updating data and bounds"},{"id":142,"pagetitle":"Manual","title":"Getting times and timesteps","ref":"/NamedTrajectories/stable/generated/manual/#Getting-times-and-timesteps","content":" Getting times and timesteps"},{"id":143,"pagetitle":"Manual","title":"Operations with other trajectories","ref":"/NamedTrajectories/stable/generated/manual/#Operations-with-other-trajectories","content":" Operations with other trajectories"},{"id":144,"pagetitle":"Manual","title":"Copying and equality","ref":"/NamedTrajectories/stable/generated/manual/#Copying-and-equality","content":" Copying and equality This page was generated using  Literate.jl ."},{"id":147,"pagetitle":"Plotting","title":"Plotting","ref":"/NamedTrajectories/stable/generated/plotting/#Plotting","content":" Plotting Visualizing trajectories is crucial for understanding the solutions of trajectory optmization problems and  NamedTrajectories  exports a  plot  function that contains a lot of functionality that is continually being added to.  Makie.jl  is used as the plotting framework, and at the moment the default backend is  CairoMakie , as it creates high quality vector graphics. The function is called as follows:"},{"id":148,"pagetitle":"Plotting","title":"MakieCore.plot","ref":"/NamedTrajectories/stable/generated/plotting/#MakieCore.plot","content":" MakieCore.plot  —  Function plot(traj::NamedTrajectory, comps=traj.names; kwargs...) Plot a  NamedTrajectory  using  CairoMakie . Arguments traj::NamedTrajectory : the trajectory to plot comps::Union{Symbol, Vector{Symbol}, Tuple{Vararg{Symbol}}} : the components of the trajectory to plot, e.g.,  :x ,  [:x, :u] , or  (:x, :u) . Keyword Arguments component specification ignored_labels::Union{Symbol, Vector{Symbol}, Tuple{Vararg{Symbol}}} : the components of the trajectory to ignore. The default is  () . ignore_timestep::Bool : whether or not to ignore the timestep component of the trajectory. The default is  true . transformations transformations::OrderedDict{Symbol, <:Union{Function, Vector}} : a dictionary of transformations to apply to the components of the trajectory. The keys of the dictionary are the components of the trajectory to transform, and the values are either a single function or a vector of functions to apply to each column of the component. If a single function is provided, it is applied to each column of the component. If a vector of functions is provided, a separate plot is created for each function. The default is an empty  OrderedDict . transformation_labels::Union{Nothing, OrderedDict{Symbol, <:Union{Nothing, <:AbstractString, Vector{<:Union{Nothing, <:AbstractString}}}}} : a dictionary of labels for the transformed components of the trajectory. The keys of the dictionary are the components of the trajectory to transform, and the values are either a single string or a vector of strings that correspond to a vector of transformations. If a single string is provided, it is applied to each transformation of the component. If a vector of strings is provided, a separate label is created for each function. The default is  nothing . include_transformation_labels::Union{Bool, Vector{<:Union{Bool, Vector{Bool}}}} : a boolean, vector of booleans, or vector of vectors of booleans, that determines whether or not to include the labels for the transformed components of the trajectory. The default is  false . transformation_titles::Union{Nothing, OrderedDict{Symbol, <:Union{<:AbstractString, Vector{String}}}} : a dictionary of titles for the transformed components of the trajectory. The keys of the dictionary are the components of the trajectory to transform, and the values are either a single string or a vector of strings that correspond to a vector of transformations. If a single string is provided, it is applied to each transformation of the component. If a vector of strings is provided, a separate title is created for each function. The default is  nothing . style fig_size::Tuple{Int, Int} : the size of the figure,  (width, height) . The default is  (1200, 800) . titlesize::Int : the size of the titles. The default is  25 . series_color::Symbol : the color of the series. The default is  :glasbey_bw_minc_20_n256 . See options  here markersize : the size of the markers. The default is  5 . other kwargs... : keyword arguments passed to  CairoMakie.series! . source"},{"id":149,"pagetitle":"Plotting","title":"Basic example","ref":"/NamedTrajectories/stable/generated/plotting/#Basic-example","content":" Basic example Let's first create a simple trajectory to plot using NamedTrajectories\n\n# define the number timestamps\nT = 100\nΔt = 0.1\nts = [0:T-1...] * Δt\n\n# define sinusoidal state trajectories\nX = zeros(3, T)\nX[1, :] = sin.(3 * 2π * ts / (2 * (T - 1) * Δt))\nX[2, :] = -sin.(5 * 2π * ts / (2 * (T - 1) * Δt))\nX[3, :] = sin.(9 * 2π * ts / (2 * (T - 1) * Δt))\n\n# define gaussian shaped controls\nU = stack(\n    [\n        exp.(-((ts .- ts[length(ts)÷3]) / 2.0).^2) .* sin.(5.0 * ts),\n        exp.(-((ts .- ts[2(length(ts)÷3)]) / 1.5).^2) .* sin.(4.0 * ts)\n    ];\n    dims=1\n)\nV = exp.(-((ts .- ts[length(ts)÷2]) ./ 1.5).^2) .* sin.(6.0 * ts)\n\n# create the trajectory\ntraj = NamedTrajectory(\n    (\n        x=X,\n        u=U,\n        v=V\n    );\n    timestep=Δt,\n    controls=(:u, :v)\n)\n\n# plot the trajectory\nplot(traj)"},{"id":150,"pagetitle":"Plotting","title":"Selectively plotting components","ref":"/NamedTrajectories/stable/generated/plotting/#Selectively-plotting-components","content":" Selectively plotting components We can selectively plot components of the trajectory by passing a  Vector  of  Symbol s to the  components  keyword argument. For example, if we only wanted to plot the state and the first control we could do the following: plot(traj, [:x, :u])"},{"id":151,"pagetitle":"Plotting","title":"Playing with transformations","ref":"/NamedTrajectories/stable/generated/plotting/#Playing-with-transformations","content":" Playing with transformations We can also apply transformations to the components of the trajectory. Transformations are performed on columns of the data. For example, if we wanted to plot absolute values of the states we could do the following: transformations = OrderedDict(\n    :x => x -> abs.(x),\n)\n\nplot(traj, [:x]; transformations=transformations) We can also pass multiple transformations to the same component, with selective labels and titles: # define the transformations\ntransformations = OrderedDict(\n    :x => [\n        x -> [x[1] + x[2], x[3] - x[2]],\n        x -> [x[1] - x[2], x[3] + x[2]]\n    ],\n)\n\n# define the labels\ntransformation_labels = OrderedDict(\n    :x => [\n        \"\\\\tilde{x}\",\n        \"\\\\hat{x}\"\n    ],\n)\n\n# define the titles\ntransformation_titles = OrderedDict(\n    :x => [\n        L\"x_1 + x_2, x_3 - x_2\",\n        L\"x_1 - x_2, x_3 + x_2\"\n    ],\n)\n\n# plot the trajectory, with only the transformation and the `u` control\nplot(traj, [:u];\n    transformations=transformations,\n    transformation_labels=transformation_labels,\n    include_transformation_labels=[[true, true]],\n    transformation_titles=transformation_titles,\n) This page was generated using  Literate.jl ."},{"id":154,"pagetitle":"Quickstart Guide","title":"Quickstart Guide","ref":"/NamedTrajectories/stable/generated/quickstart/#Quickstart-Guide","content":" Quickstart Guide"},{"id":155,"pagetitle":"Quickstart Guide","title":"Getting set up","ref":"/NamedTrajectories/stable/generated/quickstart/#Getting-set-up","content":" Getting set up To install  NamedTrajectories  simply enter the package manager in the Julia REPL with  ]  and run pkg> add NamedTrajectories Then just use the package as usual with using NamedTrajectories For the following examples let's work with a simple trajectory \\[\\qty{z_t = \\mqty(x_t \\\\ u_t)}_{t=1:T}\\] where  $x_t$  is the state and  $u_t$  is the control at a time indexed by  $t$ . Together  $z_t$  is referred to as a  knot point  and a  NamedTrajectory  essentially just stores a collection of knot points and makes it easy to access the state and control variables."},{"id":156,"pagetitle":"Quickstart Guide","title":"Creating a fixed-timestep NamedTrajectory","ref":"/NamedTrajectories/stable/generated/quickstart/#Creating-a-fixed-timestep-NamedTrajectory","content":" Creating a fixed-timestep  NamedTrajectory Here we will createa a  NamedTrajectory  with a fixed timestep. This is done by passing a scalar as the  timestep  kwarg. # define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n)\n\n# we must specify a timestep and control variable for the trajectory\ntimestep = 0.1\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(data; timestep=timestep, controls=control)\n\n# we can return the names of the stored variables\ntraj.names (:x, :u) Let's plot this trajectory plot(traj)"},{"id":157,"pagetitle":"Quickstart Guide","title":"Creating a variable-timestep NamedTrajectory","ref":"/NamedTrajectories/stable/generated/quickstart/#Creating-a-variable-timestep-NamedTrajectory","content":" Creating a variable-timestep  NamedTrajectory Here we will create a  NamedTrajectory  with a variable timestep. This is done by passing a  Symbol , corresponding to component of the data, as the  timestep  kwarg. # define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = rand(T),\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(data; timestep=timestep, controls=control)\n\n# we can return the names of the stored variables\ntraj.names (:x, :u, :Δt)"},{"id":158,"pagetitle":"Quickstart Guide","title":"Adding more problem data","ref":"/NamedTrajectories/stable/generated/quickstart/#Adding-more-problem-data","content":" Adding more problem data In many settings we will want to add problem data to our  NamedTrajectory  – e.g. bounds, initial values, final values, and goal values. This is realized by passing NamedTuples containing this data. # define the number of timesteps\nT = 10\n\n# define the knot point data as a NamedTuple of matrices\ndata = (\n    x = rand(3, T),\n    u = rand(2, T),\n    Δt = rand(T),\n)\n\n# define initial values\ninitial = (\n    x = [1.0, 0.0, 0.0],\n    u = [0.0, 0.0],\n)\n\n# define final value, here just on the control\nfinal = (\n    u = [0.0, 0.0],\n)\n\n# define bounds\nbounds = (\n    x = 1.0,\n    u = 1.0\n)\n\n# set a goal for the state\ngoal = (\n    x = [0.0, 0.0, 1.0],\n)\n\n# we must specify a timestep and control variable for the NamedTrajectory\ntimestep = :Δt\ncontrol = :u\n\n# we can now create a `NamedTrajectory` object\ntraj = NamedTrajectory(\n    data;\n    timestep=timestep,\n    controls=control,\n    initial=initial,\n    final=final,\n    bounds=bounds,\n    goal=goal\n)\n\n# we can then show the bounds\ntraj.goal (x = [0.0, 0.0, 1.0],)"},{"id":159,"pagetitle":"Quickstart Guide","title":"Retrieving data","ref":"/NamedTrajectories/stable/generated/quickstart/#Retrieving-data","content":" Retrieving data There are a number of ways to access data, for example traj.x 3×10 Matrix{Float64}:\n 0.339772  0.458011  0.808673   0.810924  …  0.605286  0.433245  0.472111\n 0.475     0.176688  0.0391139  0.5282       0.499439  0.258999  0.987082\n 0.884408  0.392084  0.176183   0.812569     0.664802  0.294856  0.722683 returns the data matrix associated with the state variable  x . traj.data 6×10 reshape(view(::Vector{Float64}, :), 6, 10) with eltype Float64:\n 0.339772  0.458011  0.808673   0.810924   …  0.605286  0.433245  0.472111\n 0.475     0.176688  0.0391139  0.5282        0.499439  0.258999  0.987082\n 0.884408  0.392084  0.176183   0.812569      0.664802  0.294856  0.722683\n 0.989048  0.524702  0.0146634  0.0903063     0.697352  0.536413  0.515899\n 0.245487  0.198962  0.026631   0.0221841     0.499686  0.427416  0.800935\n 0.666301  0.588193  0.0227659  0.74916    …  0.905327  0.40828   0.872352 returns the all of the data as a matrix where each column is a knot point. traj.datavec 60-element Vector{Float64}:\n 0.3397717188399447\n 0.4749996197418046\n 0.8844080846299748\n 0.9890477882571549\n 0.24548746414774825\n 0.6663011881741285\n 0.45801052956750843\n 0.17668843849673366\n 0.39208387030612213\n 0.5247017708732374\n ⋮\n 0.53641270445415\n 0.42741570371746584\n 0.40827955001498695\n 0.4721106341536885\n 0.987081777648369\n 0.7226826899871555\n 0.5158991782222441\n 0.8009349815381217\n 0.872351801302637 returns the all of the data as a view of the data matrix as a vector – useful for passing data to solvers. traj[1] KnotPoint(1, [0.3397717188399447, 0.4749996197418046, 0.8844080846299748, 0.9890477882571549, 0.24548746414774825, 0.6663011881741285], 0.6663011881741285, (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3], controls = [4, 5, 6]), (:x, :u, :Δt), (:u, :Δt)) returns a  KnotPoint . traj[1].x 3-element Vector{Float64}:\n 0.3397717188399447\n 0.4749996197418046\n 0.8844080846299748 returns the state at the first knot point. get_times(traj) 10-element Vector{Float64}:\n 0.0\n 0.6663011881741285\n 1.254493945859989\n 1.2772598147950323\n 2.0264197775237873\n 2.1064604595330456\n 2.208729562579105\n 3.0683799885400234\n 3.973706772397252\n 4.381986322412239 returns the times of the knot points. get_timesteps(traj) 10-element Vector{Float64}:\n 0.6663011881741285\n 0.5881927576858605\n 0.022765868935043065\n 0.749159962728755\n 0.0800406820092584\n 0.10226910304605963\n 0.8596504259609181\n 0.9053267838572284\n 0.40827955001498695\n 0.872351801302637 returns the timesteps of the knot points, as vector."},{"id":160,"pagetitle":"Quickstart Guide","title":"Retrieving metadata","ref":"/NamedTrajectories/stable/generated/quickstart/#Retrieving-metadata","content":" Retrieving metadata We can also retrieve metadata about the trajectory, for example traj.names (:x, :u, :Δt) returns the names of the variables stored in the trajectory. traj.dims (x = 3, u = 2, Δt = 1, states = 3, controls = 3) returns the dimensions of the variables stored in the trajectory. traj.T 10 returns the number of knot points in the trajectory. traj.components (x = 1:3, u = 4:5, Δt = 6:6, states = [1, 2, 3], controls = [4, 5, 6]) returns the components of the trajectory. This page was generated using  Literate.jl ."},{"id":163,"pagetitle":"Library","title":"API","ref":"/NamedTrajectories/stable/lib/#API","content":" API"},{"id":164,"pagetitle":"Library","title":"NamedTrajectory methods","ref":"/NamedTrajectories/stable/lib/#NamedTrajectory-methods","content":" NamedTrajectory methods"},{"id":165,"pagetitle":"Library","title":"Base.:==","ref":"/NamedTrajectories/stable/lib/#Base.:==-Tuple{NamedTrajectory, NamedTrajectory}","content":" Base.:==  —  Method :(==)(traj1::NamedTrajectory, traj2::NamedTrajectory) Check if trajectories are equal w.r.t. using  Base.:(==) source"},{"id":166,"pagetitle":"Library","title":"Base.copy","ref":"/NamedTrajectories/stable/lib/#Base.copy-Tuple{NamedTrajectory}","content":" Base.copy  —  Method copy(::NamedTrajectory) Returns a copy of the trajectory. source"},{"id":167,"pagetitle":"Library","title":"Base.getindex","ref":"/NamedTrajectories/stable/lib/#Base.getindex-Tuple{NamedTrajectory, AbstractVector{Int64}}","content":" Base.getindex  —  Method getindex(traj, ts::AbstractVector{Int})::Vector{KnotPoint} Returns the knot points at times  ts . source"},{"id":168,"pagetitle":"Library","title":"Base.getindex","ref":"/NamedTrajectories/stable/lib/#Base.getindex-Tuple{NamedTrajectory, Int64}","content":" Base.getindex  —  Method getindex(traj, t::Int)::KnotPoint Returns the knot point at time  t . source"},{"id":169,"pagetitle":"Library","title":"Base.getindex","ref":"/NamedTrajectories/stable/lib/#Base.getindex-Tuple{NamedTrajectory, Symbol}","content":" Base.getindex  —  Method getindex(traj, symb::Symbol) Dispatches indexing of trajectories as either accessing a component or a property via  getproperty . source"},{"id":170,"pagetitle":"Library","title":"Base.getproperty","ref":"/NamedTrajectories/stable/lib/#Base.getproperty-Tuple{NamedTrajectory, Symbol}","content":" Base.getproperty  —  Method getproperty(traj, symb::Symbol) Returns the component of the trajectory with name  symb  or the property of the trajectory with name  symb . source"},{"id":171,"pagetitle":"Library","title":"Base.isequal","ref":"/NamedTrajectories/stable/lib/#Base.isequal-Tuple{NamedTrajectory, NamedTrajectory}","content":" Base.isequal  —  Method isequal(traj1::NamedTrajectory, traj2::NamedTrajectory) Check if trajectories are equal w.r.t. data using  Base.isequal source"},{"id":172,"pagetitle":"Library","title":"Base.lastindex","ref":"/NamedTrajectories/stable/lib/#Base.lastindex-Tuple{NamedTrajectory}","content":" Base.lastindex  —  Method lastindex(traj::NamedTrajectory) Returns the final time index of the trajectory. source"},{"id":173,"pagetitle":"Library","title":"Base.length","ref":"/NamedTrajectories/stable/lib/#Base.length-Tuple{NamedTrajectory}","content":" Base.length  —  Method length(::NamedTrajectory) Returns the length of all variables of the trajectory, including global data. source"},{"id":174,"pagetitle":"Library","title":"Base.merge","ref":"/NamedTrajectories/stable/lib/#Base.merge-Tuple{NamedTrajectory, NamedTrajectory}","content":" Base.merge  —  Method merge(traj1::NamedTrajectory, traj2::NamedTrajectory)\nmerge(trajs::AbstractVector{<:NamedTrajectory}) Returns a new NamedTrajectory object by merging  NamedTrajectory  objects.  Merge names are used to specify which components to merge by index. If no merge names are provided, all components are merged and name collisions are not allowed. If merge names are provided, the names are merged using the data from the index provided in the merge names. Joined  NamedTrajectory  objects must have the same timestep. If a free time trajectory is desired, setting the keyword argument  free_time=true  will construct the a component for the timestep. In this case, the timestep symbol must be provided.  Arguments traj1::NamedTrajectory : The first  NamedTrajectory  object. traj2::NamedTrajectory : The second  NamedTrajectory  object. free_time::Bool=false : Whether to construct a free time problem. timestep_name::Symbol=:Δt : The timestep symbol to use for free time problems. merge_names::Union{Nothing, NamedTuple{<:Any, <:Tuple{Vararg{Int}}}}=nothing : The names to merge by index. source"},{"id":175,"pagetitle":"Library","title":"Base.setproperty!","ref":"/NamedTrajectories/stable/lib/#Base.setproperty!-Tuple{NamedTrajectory, Symbol, Any}","content":" Base.setproperty!  —  Method setproperty!(traj, name::Symbol, val::Any) Dispatches setting properties of trajectories as either setting a component or a property via  setfield!  or  update! . source"},{"id":176,"pagetitle":"Library","title":"Base.size","ref":"/NamedTrajectories/stable/lib/#Base.size-Tuple{NamedTrajectory}","content":" Base.size  —  Method size(traj::NamedTrajectory) = (dim = traj.dim, T = traj.T) Returns the size of the trajectory (dim, T), excluding global data. TODO: Should global data be in size? source"},{"id":177,"pagetitle":"Library","title":"Base.vec","ref":"/NamedTrajectories/stable/lib/#Base.vec-Tuple{NamedTrajectory}","content":" Base.vec  —  Method vec(::NamedTrajectory) Returns all variables of the trajectory as a vector, Z⃗. source"},{"id":178,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.add_component!","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.add_component!-Tuple{NamedTrajectory, Symbol, AbstractVecOrMat{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.add_component!  —  Method add_component!(traj, name::Symbol, data::AbstractVecOrMat; type={:state, :control}) Add a component to the trajectory. This function resizes the trajectory, so global components and components must be adjusted. source"},{"id":179,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_component_names","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.get_component_names-Tuple{NamedTrajectory, AbstractVector{<:Int64}}","content":" NamedTrajectories.MethodsNamedTrajectory.get_component_names  —  Method get_component_names(traj::NamedTrajectory, comps::AbstractVector{<:Int}) Returns the name of the component with the given indices. If only one component is found, the name is returned as a single symbol. Else, the names are returned as a vector of symbols. The filter requires that the components are a complete subset of the given indices, so that a partial match is excluded from the returned names. source"},{"id":180,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_components","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.get_components-Tuple{Union{Tuple, AbstractVector}, NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_components  —  Method get_components(::NamedTrajectory) Returns a NamedTuple containing the names and corresponding data matrices of the trajectory. source"},{"id":181,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_duration","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.get_duration-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_duration  —  Method get_duration(::NamedTrajectory) Returns the duration of a trajectory. source"},{"id":182,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_times","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.get_times-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_times  —  Method get_times(traj)::Vector{Float64} Returns the times of a trajectory as a vector. source"},{"id":183,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.get_timesteps","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.get_timesteps-Tuple{NamedTrajectory}","content":" NamedTrajectories.MethodsNamedTrajectory.get_timesteps  —  Method get_timesteps(::NamedTrajectory) Returns the timesteps of a trajectory as a vector. source"},{"id":184,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.merge_outer","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.merge_outer-Tuple{AbstractVector}","content":" NamedTrajectories.MethodsNamedTrajectory.merge_outer  —  Method merge_outer(objs::AbstractVector{<:Any}) Merge objects. An error is reported if a key collision is detected. source"},{"id":185,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_component","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.remove_component-Tuple{NamedTrajectory, Symbol}","content":" NamedTrajectories.MethodsNamedTrajectory.remove_component  —  Method remove_component(traj, name::Symbol) Remove a component from the trajectory. source"},{"id":186,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.remove_components","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.remove_components-Tuple{NamedTrajectory, AbstractVector{<:Symbol}}","content":" NamedTrajectories.MethodsNamedTrajectory.remove_components  —  Method remove_components(traj, names::Vector{Symbol}) Remove a set of components from the trajectory. source"},{"id":187,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, AbstractVector{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.update!  —  Method update!(traj, datavec::AbstractVector{Float64}) Update the trajectory with a new datavec. source"},{"id":188,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update!","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.update!-Tuple{NamedTrajectory, Symbol, AbstractMatrix{Float64}}","content":" NamedTrajectories.MethodsNamedTrajectory.update!  —  Method update!(traj, name::Symbol, data::AbstractMatrix{Float64}) Update a component of the trajectory. source"},{"id":189,"pagetitle":"Library","title":"NamedTrajectories.MethodsNamedTrajectory.update_bound!","ref":"/NamedTrajectories/stable/lib/#NamedTrajectories.MethodsNamedTrajectory.update_bound!","content":" NamedTrajectories.MethodsNamedTrajectory.update_bound!  —  Function update_bound!(traj, name::Symbol, data::Real)\nupdate_bound!(traj, name::Symbol, data::AbstractVector{<:Real})\nupdate_bound!(traj, name::Symbol, data::Tuple{R, R} where R <: Real) Update the bound of a component of the trajectory. source"},{"id":190,"pagetitle":"Library","title":"random trajectory methods","ref":"/NamedTrajectories/stable/lib/#random-trajectory-methods","content":" random trajectory methods"},{"id":191,"pagetitle":"Library","title":"Base.rand","ref":"/NamedTrajectories/stable/lib/#Base.rand-Tuple{Type{NamedTrajectory}, Int64}","content":" Base.rand  —  Method rand(\n    ::Type{NamedTrajectory},\n    T::Int;\n    timestep_value::Float64=1.0,\n    timestep_name::Symbol=:Δt,\n    free_time::Bool=false,\n    timestep::Union{Float64,Symbol}=free_time ? timestep_name : timestep_value,\n    state_dim::Int=3,\n    control_dim::Int=2\n) Create a random  NamedTrajectory  with  T  time steps, a state variable  x  of dimension  state_dim , and a control variable  u  of dimension  control_dim . If  free_time  is  true , the time step is a symbol  timestep_name  and the time step value is  timestep_value . Otherwise, the time step is a number  timestep_value . source"},{"id":194,"pagetitle":"Adding and removing variables","title":"Adding and removing variables","ref":"/NamedTrajectories/stable/man/add_remove/#Adding-and-removing-variables","content":" Adding and removing variables This page was generated using  Literate.jl ."},{"id":197,"pagetitle":"Constructors","title":"Constructors","ref":"/NamedTrajectories/stable/man/constructors/#Constructors","content":" Constructors This page was generated using  Literate.jl ."},{"id":200,"pagetitle":"Operations with other trajectories","title":"Operations with other trajectories","ref":"/NamedTrajectories/stable/man/operations/#Operations-with-other-trajectories","content":" Operations with other trajectories This page was generated using  Literate.jl ."},{"id":203,"pagetitle":"Retrieving data","title":"Retrieving data","ref":"/NamedTrajectories/stable/man/retrieval/#Retrieving-data","content":" Retrieving data This page was generated using  Literate.jl ."},{"id":206,"pagetitle":"Times and timesteps","title":"Times and timesteps","ref":"/NamedTrajectories/stable/man/times/#Times-and-timesteps","content":" Times and timesteps This page was generated using  Literate.jl ."},{"id":209,"pagetitle":"Updating data","title":"Updating data","ref":"/NamedTrajectories/stable/man/updating/#Updating-data","content":" Updating data This page was generated using  Literate.jl ."},{"id":212,"pagetitle":"Manual","title":"Manual","ref":"/NamedTrajectories/stable/manual/#Manual","content":" Manual"},{"id":213,"pagetitle":"Manual","title":"Constructors","ref":"/NamedTrajectories/stable/manual/#Constructors","content":" Constructors"},{"id":214,"pagetitle":"Manual","title":"Retrieving data","ref":"/NamedTrajectories/stable/manual/#Retrieving-data","content":" Retrieving data"},{"id":215,"pagetitle":"Manual","title":"Adding and removing variables","ref":"/NamedTrajectories/stable/manual/#Adding-and-removing-variables","content":" Adding and removing variables"},{"id":216,"pagetitle":"Manual","title":"Updating data and bounds","ref":"/NamedTrajectories/stable/manual/#Updating-data-and-bounds","content":" Updating data and bounds"},{"id":217,"pagetitle":"Manual","title":"Getting times and timesteps","ref":"/NamedTrajectories/stable/manual/#Getting-times-and-timesteps","content":" Getting times and timesteps"},{"id":218,"pagetitle":"Manual","title":"Operations with other trajectories","ref":"/NamedTrajectories/stable/manual/#Operations-with-other-trajectories","content":" Operations with other trajectories"},{"id":219,"pagetitle":"Manual","title":"Copying and equality","ref":"/NamedTrajectories/stable/manual/#Copying-and-equality","content":" Copying and equality This page was generated using  Literate.jl ."}]