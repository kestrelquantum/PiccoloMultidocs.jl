<!DOCTYPE html><HTML lang="en"><head><script charset="utf-8" src="../../../assets/default/multidoc_injector.js" type="text/javascript"></script><script charset="utf-8" type="text/javascript">window.MULTIDOCUMENTER_ROOT_PATH = '/'</script><script charset="utf-8" src="../../../assets/default/flexsearch.bundle.js" type="text/javascript"></script><script charset="utf-8" src="../../../assets/default/flexsearch_integration.js" type="text/javascript"></script><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Library · QuantumCollocation.jl</title><meta content="Library · QuantumCollocation.jl" name="title"/><meta content="Library · QuantumCollocation.jl" property="og:title"/><meta content="Library · QuantumCollocation.jl" property="twitter:title"/><meta content="Documentation for QuantumCollocation.jl." name="description"/><meta content="Documentation for QuantumCollocation.jl." property="og:description"/><meta content="Documentation for QuantumCollocation.jl." property="twitter:description"/><meta content="https://docs.harmoniqs.co/QuantumCollocation.jl/lib/" property="og:url"/><meta content="https://docs.harmoniqs.co/QuantumCollocation.jl/lib/" property="twitter:url"/><link href="https://docs.harmoniqs.co/QuantumCollocation/dev/lib/" rel="canonical"/><script data-outdated-warner="" src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" data-theme-name="catppuccin-mocha" href="../assets/themes/catppuccin-mocha.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-macchiato" href="../assets/themes/catppuccin-macchiato.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-frappe" href="../assets/themes/catppuccin-frappe.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="catppuccin-latte" href="../assets/themes/catppuccin-latte.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-dark" data-theme-primary-dark="" href="../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../assets/themeswap.js"></script><link href="../../../assets/default/multidoc.css" rel="stylesheet" type="text/css"/><link href="../../../assets/default/flexsearch.css" rel="stylesheet" type="text/css"/></head><body><nav id="multi-page-nav"><div class="hidden-on-mobile" id="nav-items"><a class="nav-link nav-item" href="../../../Piccolo/">Piccolo</a><a class="nav-link nav-item" href="../../../PiccoloQuantumObjects/">Quantum Objects</a><div class="nav-dropdown"><button class="nav-item dropdown-label">Optimal Controls</button><ul class="nav-dropdown-container"><a class="nav-link active nav-item" href="../../">QuantumCollocation.jl</a><a class="nav-link nav-item" href="../../../QuantumCollocationCore/">QuantumCollocationCore.jl</a></ul></div><div class="nav-dropdown"><button class="nav-item dropdown-label">Trajectories</button><ul class="nav-dropdown-container"><a class="nav-link nav-item" href="../../../NamedTrajectories/">NamedTrajectories.jl</a><a class="nav-link nav-item" href="../../../TrajectoryIndexingUtils/">TrajectoryIndexingUtils.jl</a></ul></div><a class="nav-link nav-item" href="../../../PiccoloPlots/">Plots</a><div class="search nav-item"><input id="search-input" placeholder="Search everywhere..."/><ul class="suggestions hidden" id="search-result-container"></ul><div class="search-keybinding">/</div></div></div><button id="multidoc-toggler"><svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg></button></nav><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img alt="QuantumCollocation.jl logo" src="../assets/logo.svg"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">QuantumCollocation.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../generated/man/problem_templates/">Problem Templates</a></li><li><a class="tocitem" href="../generated/man/rollouts/">Rollouts</a></li><li><a class="tocitem" href="../generated/man/ipopt_callbacks/">Callbacks</a></li></ul></li><li class="is-active"><a class="tocitem" href="">Library</a><ul class="internal"><li><a class="tocitem" href="#Problem-Templates"><span>Problem Templates</span></a></li><li><a class="tocitem" href="#Options"><span>Options</span></a></li><li><a class="tocitem" href="#Rollouts"><span>Rollouts</span></a></li><li><a class="tocitem" href="#Direct-Sums"><span>Direct Sums</span></a></li><li><a class="tocitem" href="#Trajectory-Initialization"><span>Trajectory Initialization</span></a></li><li><a class="tocitem" href="#Trajectory-Interpolations"><span>Trajectory Interpolations</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="">Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">Library</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/harmoniqs/QuantumCollocation.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/main/docs/src/lib.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" href="javascript:;" id="documenter-article-toggle-button" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><h2 id="Problem-Templates"><a class="docs-heading-anchor" href="#Problem-Templates">Problem Templates</a><a id="Problem-Templates-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Templates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem" id="QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem"><code>QuantumCollocation.ProblemTemplates.QuantumStateMinimumTimeProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumStateMinimumTimeProblem(traj, sys, obj, integrators, constraints; kwargs...)
QuantumStateMinimumTimeProblem(prob; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for the minimum time problem of reaching a target state.</p><p><strong>Arguments</strong></p><ul><li><code>traj::NamedTrajectory</code>: The initial trajectory.</li><li><code>sys::QuantumSystem</code>: The quantum system.</li><li><code>obj::Objective</code>: The objective function.</li><li><code>integrators::Vector{&lt;:AbstractIntegrator}</code>: The integrators.</li><li><code>constraints::Vector{&lt;:AbstractConstraint}</code>: The constraints.</li></ul><p>or</p><ul><li><code>prob::QuantumControlProblem</code>: The quantum control problem.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>state_name::Symbol=:ψ̃</code>: The symbol for the state variables.</li><li><code>final_fidelity::Union{Real, Nothing}=nothing</code>: The final fidelity.</li><li><code>D=1.0</code>: The cost weight on the time.</li><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: The Ipopt options.</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The Piccolo options.</li><li><code>kwargs...</code>: Additional keyword arguments, passed to <code>QuantumControlProblem</code>.</li></ul></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/problem_templates/quantum_state_minimum_time_problem.jl#L4-L27" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem" id="QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem"><code>QuantumCollocation.ProblemTemplates.QuantumStateSmoothPulseProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QuantumStateSmoothPulseProblem(system, ψ_inits, ψ_goals, T, Δt; kwargs...)
QuantumStateSmoothPulseProblem(system, ψ_init, ψ_goal, T, Δt; kwargs...)
QuantumStateSmoothPulseProblem(H_drift, H_drives, args...; kwargs...)</code></pre><p>Create a quantum state smooth pulse problem. The goal is to find a control pulse <code>a(t)</code> that drives all of the initial states <code>ψ_inits</code> to the corresponding target states <code>ψ_goals</code> using <code>T</code> timesteps of size <code>Δt</code>. This problem also controls the first and second derivatives of the control pulse, <code>da(t)</code> and <code>dda(t)</code>, to ensure smoothness.</p><p><strong>Arguments</strong></p><ul><li><code>system::AbstractQuantumSystem</code>: The quantum system.</li></ul><p>or</p><ul><li><code>H_drift::AbstractMatrix{&lt;:Number}</code>: The drift Hamiltonian.</li><li><code>H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}}</code>: The control Hamiltonians.</li></ul><p>with</p><ul><li><code>ψ_inits::Vector{&lt;:AbstractVector{&lt;:ComplexF64}}</code>: The initial states.</li><li><code>ψ_goals::Vector{&lt;:AbstractVector{&lt;:ComplexF64}}</code>: The target states.</li></ul><p>or</p><ul><li><code>ψ_init::AbstractVector{&lt;:ComplexF64}</code>: The initial state.</li><li><code>ψ_goal::AbstractVector{&lt;:ComplexF64}</code>: The target state.</li></ul><p>with</p><ul><li><code>T::Int</code>: The number of timesteps.</li><li><code>Δt::Float64</code>: The timestep size.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: The IPOPT options.</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The Piccolo options.</li><li><code>state_name::Symbol=:ψ̃</code>: The name of the state variable.</li><li><code>control_name::Symbol=:a</code>: The name of the control variable.</li><li><code>timestep_name::Symbol=:Δt</code>: The name of the timestep variable.</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}=nothing</code>: The initial trajectory.</li><li><code>a_bound::Float64=1.0</code>: The bound on the control pulse.</li><li><code>a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives))</code>: The bounds on the control pulse.</li><li><code>a_guess::Union{Matrix{Float64}, Nothing}=nothing</code>: The initial guess for the control pulse.</li><li><code>da_bound::Float64=Inf</code>: The bound on the first derivative of the control pulse.</li><li><code>da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives))</code>: The bounds on the first derivative of the control pulse.</li><li><code>zero_initial_and_final_derivative::Bool=false</code>: Whether to enforce zero initial and final derivative.</li><li><code>dda_bound::Float64=1.0</code>: The bound on the second derivative of the control pulse.</li><li><code>dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives))</code>: The bounds on the second derivative of the control pulse.</li><li><code>Δt_min::Float64=0.5 * Δt</code>: The minimum timestep size.</li><li><code>Δt_max::Float64=1.5 * Δt</code>: The maximum timestep size.</li><li><code>drive_derivative_σ::Float64=0.01</code>: The standard deviation of the drive derivative random initialization.</li><li><code>Q::Float64=100.0</code>: The weight on the state objective.</li><li><code>R=1e-2</code>: The weight on the control pulse and its derivatives.</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: The weight on the control pulse.</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: The weight on the first derivative of the control pulse.</li><li><code>R_dda::Union{Float64, Vector{Float64}}=R</code>: The weight on the second derivative of the control pulse.</li><li><code>leakage_operator::Union{Nothing, EmbeddedOperator}=nothing</code>: The leakage operator, if leakage suppression is desired.</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: The constraints.</li></ul></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/problem_templates/quantum_state_smooth_pulse_problem.jl#L4-L54" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem" id="QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem"><code>QuantumCollocation.ProblemTemplates.UnitaryBangBangProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryBangBangProblem(system::QuantumSystem, operator, T, Δt; kwargs...)
UnitaryBangBangProblem(H_drift, H_drives, operator, T, Δt; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for a free-time unitary gate problem with bang-bang control pulses.</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{U}}, a, \dot{a}, \Delta t}{\text{minimize}} &amp; \quad
Q \cdot \ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) + R_{\text{bang-bang}} \cdot \sum_t |\dot{a}_t| \\
\text{ subject to } &amp; \quad \vb{P}^{(n)}\qty(\vec{\tilde{U}}_{t+1}, \vec{\tilde{U}}_t, a_t, \Delta t_t) = 0 \\
&amp; \quad a_{t+1} - a_t - \dot{a}_t \Delta t_t = 0 \\
&amp; \quad |a_t| \leq a_{\text{bound}} \\
&amp; \quad |\dot{a}_t| \leq da_{\text{bound}} \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p>where, for <span>$U \in SU(N)$</span>,</p><p class="math-container">\[\ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) =
\abs{1 - \frac{1}{N} \abs{ \tr \qty(U_{\text{goal}}, U_T)} }\]</p><p>is the <em>infidelity</em> objective function, <span>$Q$</span> is a weight, <span>$R_a$</span>, and <span>$R_{\dot{a}}$</span> are weights on the regularization terms, and <span>$\vb{P}^{(n)}$</span> is the <span>$n$</span>th-order Pade integrator.</p><p>TODO: Document bang-bang modification.</p><p><strong>Arguments</strong></p><ul><li><code>H_drift::AbstractMatrix{&lt;:Number}</code>: the drift hamiltonian</li><li><code>H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}}</code>: the control hamiltonians</li></ul><p>or</p><ul><li><code>system::QuantumSystem</code>: the system to be controlled</li></ul><p>with</p><ul><li><code>operator::AbstractPiccoloOperator</code>: the target unitary, either in the form of an <code>EmbeddedOperator</code> or a `Matrix{ComplexF64}</li><li><code>T::Int</code>: the number of timesteps</li><li><code>Δt::Float64</code>: the (initial) time step size</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: the options for the Ipopt solver</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: the options for the Piccolo solver</li><li><code>state_name::Symbol = :Ũ⃗</code>: the name of the state variable</li><li><code>control_name::Symbol = :a</code>: the name of the control variable</li><li><code>timestep_name::Symbol = :Δt</code>: the name of the timestep variable</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}=nothing</code>: an initial trajectory to use</li><li><code>a_bound::Float64=1.0</code>: the bound on the control pulse</li><li><code>a_bounds=fill(a_bound, length(system.G_drives))</code>: the bounds on the control pulses, one for each drive</li><li><code>a_guess::Union{Matrix{Float64}, Nothing}=nothing</code>: an initial guess for the control pulses</li><li><code>da_bound::Float64=1.0</code>: the bound on the control pulse derivative</li><li><code>da_bounds=fill(da_bound, length(system.G_drives))</code>: the bounds on the control pulse derivatives, one for each drive</li><li><code>Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt)</code>: the minimum time step size</li><li><code>Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt)</code>: the maximum time step size</li><li><code>drive_derivative_σ::Float64=0.01</code>: the standard deviation of the initial guess for the control pulse derivatives</li><li><code>Q::Float64=100.0</code>: the weight on the infidelity objective</li><li><code>R=1e-2</code>: the weight on the regularization terms</li><li><code>quadratic_control_regularization=false</code>: whether or not to use quadratic regularization for the control pulses</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulses</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse derivatives</li><li><code>R_bang_bang::Union{Float64, Vector{Float64}}=1e-1</code>: the weight on the bang-bang regularization term</li><li><code>phase_operators::Union{AbstractVector{&lt;:AbstractMatrix}, Nothing}=nothing</code>: the phase operators for free phase corrections</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: the constraints to enforce</li></ul></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/problem_templates/unitary_bang_bang_problem.jl#L4-L67" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem-Tuple{AbstractVector{&lt;:QuantumControlProblem}, Real}" id="QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem-Tuple{AbstractVector{&lt;:QuantumControlProblem}, Real}"><code>QuantumCollocation.ProblemTemplates.UnitaryDirectSumProblem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryDirectSumProblem(probs, final_fidelity; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> as a direct sum of unitary gate problems. The purpose is to find solutions that are as close as possible with respect to one of their components. In particular, this is useful for finding interpolatable control solutions.</p><p>A graph of edges (specified by problem labels) will enforce a <code>PairwiseQuadraticRegularizer</code> between the component trajectories of the problem in <code>probs</code> corresponding to the names of the edge in <code>edges</code> with corresponding edge weight <code>Q</code>.</p><p>Boundary values can be included to enforce a <code>QuadraticRegularizer</code> on edges where one of the nodes is not optimized. The boundary values are specified as a dictionary with keys corresponding to the edge labels and values corresponding to the boundary values.</p><p>The default behavior is to use a 1D chain for the graph, i.e., enforce a <code>PairwiseQuadraticRegularizer</code> between each neighbor of the provided <code>probs</code>.</p><p><strong>Arguments</strong></p><ul><li><code>probs::AbstractVector{&lt;:QuantumControlProblem}</code>: the problems to combine</li><li><code>final_fidelity::Real</code>: the fidelity to enforce between the component final unitaries and the component goal unitaries</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>prob_labels::AbstractVector{&lt;:String}}</code>: the labels for the problems</li><li>graph::Union{Nothing, AbstractVector{&lt;:Tuple{String, String}}, AbstractVector{&lt;:Tuple{Symbol, Symbol}}}`: the graph of edges to enforce</li><li><code>boundary_values::Union{Nothing, AbstractDict{&lt;:String, &lt;:AbstractArray}, AbstractDict{&lt;:Symbol, &lt;:AbstractVector}}=nothing</code>: the boundary values for the problems</li><li><code>Q::Union{Float64, Vector{Float64}}=100.0</code>: the weights on the pairwise regularizers</li><li><code>Q_symb::Symbol=:Ũ⃗</code>: the symbol to use for the regularizer</li><li><code>R::Float64=1e-2</code>: the shared weight on all control terms (:a, :da, :dda is assumed)</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulses</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse derivatives</li><li><code>R_dda::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse second derivatives</li><li><code>R_b::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the boundary values</li><li><code>drive_derivative_σ::Float64=0.01</code>: the standard deviation of the initial guess for the control pulse derivatives</li><li><code>drive_reset_ratio::Float64=0.1</code>: amount of random noise to add to the control data (can help avoid hitting restoration if provided problems are converged)</li><li><code>fidelity_cost::Bool=false</code>: whether or not to include a fidelity cost in the objective</li><li><code>subspace::Union{AbstractVector{&lt;:Integer}, Nothing}=nothing</code>: the subspace to use for the fidelity of each problem</li><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: the options for the Ipopt solver</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: the options for the Piccolo solver</li></ul></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/problem_templates/unitary_direct_sum_problem.jl#L4-L44" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem" id="QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem"><code>QuantumCollocation.ProblemTemplates.UnitaryMinimumTimeProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryMinimumTimeProblem(
    trajectory::NamedTrajectory,
    system::AbstractQuantumSystem,
    objective::Objective,
    integrators::Vector{&lt;:AbstractIntegrator},
    constraints::Vector{&lt;:AbstractConstraint};
    kwargs...
)

UnitaryMinimumTimeProblem(
    prob::QuantumControlProblem;
    kwargs...
)</code></pre><p>Create a minimum-time problem for unitary control.</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{U}}, a, \dot{a}, \ddot{a}, \Delta t}{\text{minimize}} &amp; \quad
J(\vec{\tilde{U}}, a, \dot{a}, \ddot{a}) + D \sum_t \Delta t_t \\
\text{ subject to } &amp; \quad \vb{P}^{(n)}\qty(\vec{\tilde{U}}_{t+1}, \vec{\tilde{U}}_t, a_t, \Delta t_t) = 0 \\
&amp; c(\vec{\tilde{U}}, a, \dot{a}, \ddot{a}) = 0 \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p><strong>Arguments</strong></p><ul><li><code>trajectory::NamedTrajectory</code>: The initial trajectory.</li><li><code>system::AbstractQuantumSystem</code>: The quantum system.</li><li><code>objective::Objective</code>: The objective function (additional to the minimum-time objective).</li><li><code>integrators::Vector{&lt;:AbstractIntegrator}</code>: The integrators.</li><li><code>constraints::Vector{&lt;:AbstractConstraint}</code>: The constraints.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>unitary_name::Symbol=:Ũ⃗</code>: The symbol for the unitary control.</li><li><code>final_fidelity::Float64=0.99</code>: The final fidelity.</li><li><code>D=1.0</code>: The weight for the minimum-time objective.</li><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: The options for the Ipopt solver.</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: The options for the Piccolo solver.</li><li><code>kwargs...</code>: Additional keyword arguments to pass to <code>QuantumControlProblem</code>.</li></ul></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/problem_templates/unitary_minimum_time_problem.jl#L4-L45" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem" id="QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem"><code>QuantumCollocation.ProblemTemplates.UnitaryRobustnessProblem</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitaryRobustnessProblem(
    H_error,
    trajectory,
    system,
    objective,
    integrators,
    constraints;
    kwargs...
)

UnitaryRobustnessProblem(Hₑ, prob::QuantumControlProblem; kwargs...)</code></pre><p>Create a quantum control problem for robustness optimization of a unitary trajectory.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>unitary_name::Symbol=:Ũ⃗</code>: The symbol for the unitary trajectory in <code>trajectory</code>.</li><li><code>final_fidelity::Union{Real, Nothing}=nothing</code>: The target fidelity for the final unitary.</li><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: Options for the Ipopt solver.</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: Options for the Piccolo solver.</li><li><code>kwargs...</code>: Additional keyword arguments passed to <code>QuantumControlProblem</code>.</li></ul></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/problem_templates/unitary_robustness_problem.jl#L4-L25" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{&lt;:AbstractQuantumSystem}, AbstractVector{&lt;:AbstractPiccoloOperator}, Int64, Union{Float64, Vector{Float64}}}" id="QuantumCollocation.ProblemTemplates.UnitarySamplingProblem-Tuple{AbstractVector{&lt;:AbstractQuantumSystem}, AbstractVector{&lt;:AbstractPiccoloOperator}, Int64, Union{Float64, Vector{Float64}}}"><code>QuantumCollocation.ProblemTemplates.UnitarySamplingProblem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitarySamplingProblem(systemns, operator, T, Δt; kwargs...)</code></pre><p>A <code>UnitarySamplingProblem</code> is a quantum control problem where the goal is to find a control pulse that generates a target unitary operator for a set of quantum systems. The controls are shared among all systems, and the optimization seeks to find the control pulse that achieves the operator for each system. The idea is to enforce a robust solution by including multiple systems reflecting the problem uncertainty.</p><p><strong>Arguments</strong></p><ul><li><code>systems::AbstractVector{&lt;:AbstractQuantumSystem}</code>: A vector of quantum systems.</li><li><code>operator::AbstractPiccoloOperator</code>: The target unitary operator.</li><li><code>T::Int</code>: The number of time steps.</li><li><code>Δt::Union{Float64, Vector{Float64}}</code>: The time step value or vector of time steps.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>system_labels::Vector{String} = string.(1:length(systems))</code>: The labels for each system.</li><li><code>system_weights::Vector{Float64} = fill(1.0, length(systems))</code>: The weights for each system.</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing} = nothing</code>: The initial trajectory.</li><li><code>ipopt_options::IpoptOptions = IpoptOptions()</code>: The IPOPT options.</li><li><code>piccolo_options::PiccoloOptions = PiccoloOptions()</code>: The Piccolo options.</li><li><code>state_name::Symbol = :Ũ⃗</code>: The name of the state variable.</li><li><code>control_name::Symbol = :a</code>: The name of the control variable.</li><li><code>timestep_name::Symbol = :Δt</code>: The name of the timestep variable.</li><li><code>constraints::Vector{&lt;:AbstractConstraint} = AbstractConstraint[]</code>: The constraints.</li><li><code>a_bound::Float64 = 1.0</code>: The bound for the control amplitudes.</li><li><code>a_bounds::Vector{Float64} = fill(a_bound, length(systems[1].G_drives))</code>: The bounds for the control amplitudes.</li><li><code>a_guess::Union{Matrix{Float64}, Nothing} = nothing</code>: The initial guess for the control amplitudes.</li><li><code>da_bound::Float64 = Inf</code>: The bound for the control first derivatives.</li><li><code>da_bounds::Vector{Float64} = fill(da_bound, length(systems[1].G_drives))</code>: The bounds for the control first derivatives.</li><li><code>dda_bound::Float64 = 1.0</code>: The bound for the control second derivatives.</li><li><code>dda_bounds::Vector{Float64} = fill(dda_bound, length(systems[1].G_drives))</code>: The bounds for the control second derivatives.</li><li><code>Δt_min::Float64 = 0.5 * Δt</code>: The minimum time step size.</li><li><code>Δt_max::Float64 = 1.5 * Δt</code>: The maximum time step size.</li><li><code>Q::Float64 = 100.0</code>: The fidelity weight.</li><li><code>R::Float64 = 1e-2</code>: The regularization weight.</li><li><code>R_a::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control amplitudes.</li><li><code>R_da::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control first derivatives.</li><li><code>R_dda::Union{Float64, Vector{Float64}} = R</code>: The regularization weight for the control second derivatives.</li><li><code>kwargs...</code>: Additional keyword arguments.</li></ul></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/problem_templates/unitary_sampling_problem.jl#L4-L43" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-Tuple{AbstractQuantumSystem, AbstractPiccoloOperator, Int64, Union{Float64, AbstractVector{Float64}}}" id="QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem-Tuple{AbstractQuantumSystem, AbstractPiccoloOperator, Int64, Union{Float64, AbstractVector{Float64}}}"><code>QuantumCollocation.ProblemTemplates.UnitarySmoothPulseProblem</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">UnitarySmoothPulseProblem(system::AbstractQuantumSystem, operator, T, Δt; kwargs...)
UnitarySmoothPulseProblem(H_drift, H_drives, operator, T, Δt; kwargs...)</code></pre><p>Construct a <code>QuantumControlProblem</code> for a free-time unitary gate problem with smooth control pulses enforced by constraining the second derivative of the pulse trajectory, i.e.,</p><p class="math-container">\[\begin{aligned}
\underset{\vec{\tilde{U}}, a, \dot{a}, \ddot{a}, \Delta t}{\text{minimize}} &amp; \quad
Q \cdot \ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) + \frac{1}{2} \sum_t \qty(R_a a_t^2 + R_{\dot{a}} \dot{a}_t^2 + R_{\ddot{a}} \ddot{a}_t^2) \\
\text{ subject to } &amp; \quad \vb{P}^{(n)}\qty(\vec{\tilde{U}}_{t+1}, \vec{\tilde{U}}_t, a_t, \Delta t_t) = 0 \\
&amp; \quad a_{t+1} - a_t - \dot{a}_t \Delta t_t = 0 \\
&amp; \quad \dot{a}_{t+1} - \dot{a}_t - \ddot{a}_t \Delta t_t = 0 \\
&amp; \quad |a_t| \leq a_{\text{bound}} \\
&amp; \quad |\ddot{a}_t| \leq \ddot{a}_{\text{bound}} \\
&amp; \quad \Delta t_{\text{min}} \leq \Delta t_t \leq \Delta t_{\text{max}} \\
\end{aligned}\]</p><p>where, for <span>$U \in SU(N)$</span>,</p><p class="math-container">\[\ell\qty(\vec{\tilde{U}}_T, \vec{\tilde{U}}_{\text{goal}}) =
\abs{1 - \frac{1}{N} \abs{ \tr \qty(U_{\text{goal}}, U_T)} }\]</p><p>is the <em>infidelity</em> objective function, <span>$Q$</span> is a weight, <span>$R_a$</span>, <span>$R_{\dot{a}}$</span>, and <span>$R_{\ddot{a}}$</span> are weights on the regularization terms, and <span>$\vb{P}^{(n)}$</span> is the <span>$n$</span>th-order Pade integrator.</p><p><strong>Arguments</strong></p><ul><li><code>system::AbstractQuantumSystem</code>: the system to be controlled</li></ul><p>or</p><ul><li><code>H_drift::AbstractMatrix{&lt;:Number}</code>: the drift hamiltonian</li><li><code>H_drives::Vector{&lt;:AbstractMatrix{&lt;:Number}}</code>: the control hamiltonians</li></ul><p>with</p><ul><li><code>operator::AbstractPiccoloOperator</code>: the target unitary, either in the form of an <code>EmbeddedOperator</code> or a `Matrix{ComplexF64}</li><li><code>T::Int</code>: the number of timesteps</li><li><code>Δt::Float64</code>: the (initial) time step size</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ipopt_options::IpoptOptions=IpoptOptions()</code>: the options for the Ipopt solver</li><li><code>piccolo_options::PiccoloOptions=PiccoloOptions()</code>: the options for the Piccolo solver</li><li><code>state_name::Symbol = :Ũ⃗</code>: the name of the state</li><li><code>control_name::Symbol = :a</code>: the name of the control</li><li><code>timestep_name::Symbol = :Δt</code>: the name of the timestep</li><li><code>init_trajectory::Union{NamedTrajectory, Nothing}=nothing</code>: an initial trajectory to use</li><li><code>a_bound::Float64=1.0</code>: the bound on the control pulse</li><li><code>a_bounds::Vector{Float64}=fill(a_bound, length(system.G_drives))</code>: the bounds on the control pulses, one for each drive</li><li><code>a_guess::Union{Matrix{Float64}, Nothing}=nothing</code>: an initial guess for the control pulses</li><li><code>da_bound::Float64=Inf</code>: the bound on the control pulse derivative</li><li><code>da_bounds::Vector{Float64}=fill(da_bound, length(system.G_drives))</code>: the bounds on the control pulse derivatives, one for each drive</li><li><code>zero_initial_and_final_derivative::Bool=false</code>: whether to enforce zero initial and final control pulse derivatives</li><li><code>dda_bound::Float64=1.0</code>: the bound on the control pulse second derivative</li><li><code>dda_bounds::Vector{Float64}=fill(dda_bound, length(system.G_drives))</code>: the bounds on the control pulse second derivatives, one for each drive</li><li><code>Δt_min::Float64=Δt isa Float64 ? 0.5 * Δt : 0.5 * mean(Δt)</code>: the minimum time step size</li><li><code>Δt_max::Float64=Δt isa Float64 ? 1.5 * Δt : 1.5 * mean(Δt)</code>: the maximum time step size</li><li><code>Q::Float64=100.0</code>: the weight on the infidelity objective</li><li><code>R=1e-2</code>: the weight on the regularization terms</li><li><code>R_a::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulses</li><li><code>R_da::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse derivatives</li><li><code>R_dda::Union{Float64, Vector{Float64}}=R</code>: the weight on the regularization term for the control pulse second derivatives</li><li><code>phase_name::Symbol=:ϕ</code>: the name of the phase</li><li><code>phase_operators::Union{AbstractVector{&lt;:AbstractMatrix}, Nothing}=nothing</code>: the phase operators for free phase corrections</li><li><code>constraints::Vector{&lt;:AbstractConstraint}=AbstractConstraint[]</code>: the constraints to enforce</li></ul></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/problem_templates/unitary_smooth_pulse_problem.jl#L4-L69" target="_blank">source</a></section></article><h2 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocationCore.Options.IpoptOptions" id="QuantumCollocationCore.Options.IpoptOptions"><code>QuantumCollocationCore.Options.IpoptOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Solver options for Ipopt

https://coin-or.github.io/Ipopt/OPTIONS.html#OPT_print_options_documentation</code></pre></div><a class="docs-sourcelink" href="https://github.com/kestrelquantum/QuantumCollocationCore.jl/blob/v0.3.0/src/options.jl#L14-L18" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocationCore.Options.PiccoloOptions" id="QuantumCollocationCore.Options.PiccoloOptions"><code>QuantumCollocationCore.Options.PiccoloOptions</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PiccoloOptions</code></pre><p>Options for the Piccolo quantum optimal control library.</p><p><strong>Fields</strong></p><ul><li><code>verbose::Bool = true</code>: Print verbose output</li><li><code>verbose_evaluator::Bool = false</code>: Print verbose output from the evaluator</li><li><code>free_time::Bool = true</code>: Allow free time optimization</li><li><code>timesteps_all_equal::Bool = true</code>: Use equal timesteps</li><li><code>integrator::Symbol = :pade</code>: Integrator to use</li><li><code>pade_order::Int = 4</code>: Order of the Pade approximation</li><li><code>rollout_integrator::Function = expv</code>: Integrator to use for rollout</li><li><code>eval_hessian::Bool = false</code>: Evaluate the Hessian</li><li><code>geodesic = true</code>: Use the geodesic to initialize the optimization.</li><li><code>blas_multithreading::Bool = true</code>: Use BLAS multithreading.</li><li><code>build_trajectory_constraints::Bool = true</code>: Build trajectory constraints.</li><li><code>complex_control_norm_constraint_name::Union{Nothing, Symbol} = nothing</code>: Name of the complex control norm constraint.</li><li><code>complex_control_norm_constraint_radius::Float64 = 1.0</code>: Radius of the complex control norm constraint.</li><li><code>bound_state::Bool = false</code>: Bound the state.</li><li><code>leakage_suppression::Bool = false</code>: Suppress leakage.</li><li><code>R_leakage::Float64 = 1.0</code>: Leakage suppression parameter.</li><li><code>free_phase_infidelity::Bool = false</code>: Free phase infidelity.</li><li><code>phase_operators::Union{Nothing, AbstractVector{&lt;:AbstractMatrix{&lt;:Complex}}} = nothing</code>: Phase operators.</li><li><code>phase_name::Symbol = :ϕ</code>: Name of the phase.</li></ul></div><a class="docs-sourcelink" href="https://github.com/kestrelquantum/QuantumCollocationCore.jl/blob/v0.3.0/src/options.jl#L57-L82" target="_blank">source</a></section></article><h2 id="Rollouts"><a class="docs-heading-anchor" href="#Rollouts">Rollouts</a><a id="Rollouts-1"></a><a class="docs-heading-anchor-permalink" href="#Rollouts" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#PiccoloQuantumObjects.Rollouts.infer_is_evp-Tuple{Function}" id="PiccoloQuantumObjects.Rollouts.infer_is_evp-Tuple{Function}"><code>PiccoloQuantumObjects.Rollouts.infer_is_evp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">infer_is_evp(integrator::Function)</code></pre><p>Infer whether the integrator is a exponential-vector product (EVP) function.</p><p>If <code>true</code>, the integrator is expected to have a signature like the exponential action, <code>expv</code>. Otherwise, it is expected to have a signature like <code>exp</code>.</p></div><a class="docs-sourcelink" href="https://github.com/kestrelquantum/PiccoloQuantumObjects.jl/blob/v0.3.0/src/rollouts.jl#L66-L73" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#PiccoloQuantumObjects.Rollouts.open_rollout-Tuple{AbstractMatrix{&lt;:Complex}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}" id="PiccoloQuantumObjects.Rollouts.open_rollout-Tuple{AbstractMatrix{&lt;:Complex}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}"><code>PiccoloQuantumObjects.Rollouts.open_rollout</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">open_rollout(
    ρ₁::AbstractMatrix{&lt;:Complex},
    controls::AbstractMatrix,
    Δt::AbstractVector,
    system::AbstractQuantumSystem;
    kwargs...
)</code></pre><p>Rollout a density matrix <code>ρ₁</code> under the control <code>controls</code> and timesteps <code>Δt</code></p></div><a class="docs-sourcelink" href="https://github.com/kestrelquantum/PiccoloQuantumObjects.jl/blob/v0.3.0/src/rollouts.jl#L255-L266" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#PiccoloQuantumObjects.Rollouts.open_rollout-Tuple{AbstractVector{&lt;:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}" id="PiccoloQuantumObjects.Rollouts.open_rollout-Tuple{AbstractVector{&lt;:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}"><code>PiccoloQuantumObjects.Rollouts.open_rollout</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">open_rollout(
    ρ⃗₁::AbstractVector{&lt;:Complex},
    controls::AbstractMatrix,
    Δt::AbstractVector,
    system::AbstractQuantumSystem;
    kwargs...
)</code></pre><p>Rollout a quantum state <code>ρ⃗₁</code> under the control <code>controls</code> for a time <code>Δt</code></p><p><strong>Arguments</strong></p><ul><li><code>ρ⃗₁::AbstractVector{&lt;:Complex}</code>: Initial state vector</li><li><code>controls::AbstractMatrix</code>: Control matrix</li><li><code>Δt::AbstractVector</code>: Time steps</li><li><code>system::AbstractQuantumSystem</code>: Quantum system</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>show_progress::Bool=false</code>: Show progress bar</li><li><code>integrator::Function=expv</code>: Integrator function</li><li><code>exp_vector_product::Bool</code>: Infer whether the integrator is an exponential-vector product</li></ul></div><a class="docs-sourcelink" href="https://github.com/kestrelquantum/PiccoloQuantumObjects.jl/blob/v0.3.0/src/rollouts.jl#L200-L222" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#PiccoloQuantumObjects.Rollouts.rollout-Tuple{AbstractVector{&lt;:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}" id="PiccoloQuantumObjects.Rollouts.rollout-Tuple{AbstractVector{&lt;:Real}, AbstractMatrix, AbstractVector, AbstractQuantumSystem}"><code>PiccoloQuantumObjects.Rollouts.rollout</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rollout(
    ψ̃_init::AbstractVector{&lt;:Float64},
    controls::AbstractMatrix,
    Δt::AbstractVector,
    system::AbstractQuantumSystem
)</code></pre><p>Rollout a quantum state <code>ψ̃_init</code> under the control <code>controls</code> for a time <code>Δt</code> using the system <code>system</code>.</p><p>If <code>exp_vector_product</code> is <code>true</code>, the integrator is expected to have a signature like the exponential action, <code>expv</code>. Otherwise, it is expected to have a signature like <code>exp</code>.</p><p>Types should allow for autodifferentiable controls and times.</p></div><a class="docs-sourcelink" href="https://github.com/kestrelquantum/PiccoloQuantumObjects.jl/blob/v0.3.0/src/rollouts.jl#L94-L109" target="_blank">source</a></section></article><h2 id="Direct-Sums"><a class="docs-heading-anchor" href="#Direct-Sums">Direct Sums</a><a id="Direct-Sums-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Sums" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}" id="PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractMatrix, AbstractMatrix}"><code>PiccoloQuantumObjects.DirectSums.direct_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direct_sum(A::AbstractMatrix, B::AbstractMatrix)</code></pre><p>Returns the direct sum of two matrices.</p></div><a class="docs-sourcelink" href="https://github.com/kestrelquantum/PiccoloQuantumObjects.jl/blob/v0.3.0/src/direct_sums.jl#L16-L20" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}" id="PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{AbstractVector, AbstractVector}"><code>PiccoloQuantumObjects.DirectSums.direct_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direct_sum(Ã⃗::AbstractVector, B̃⃗::AbstractVector)</code></pre><p>Returns the direct sum of two iso_vec operators.</p></div><a class="docs-sourcelink" href="https://github.com/kestrelquantum/PiccoloQuantumObjects.jl/blob/v0.3.0/src/direct_sums.jl#L34-L38" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}" id="PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{QuantumSystem, QuantumSystem}"><code>PiccoloQuantumObjects.DirectSums.direct_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direct_sum(sys1::QuantumSystem, sys2::QuantumSystem)</code></pre><p>Returns the direct sum of two <code>QuantumSystem</code> objects.</p></div><a class="docs-sourcelink" href="https://github.com/kestrelquantum/PiccoloQuantumObjects.jl/blob/v0.3.0/src/direct_sums.jl#L48-L52" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}" id="PiccoloQuantumObjects.DirectSums.direct_sum-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>PiccoloQuantumObjects.DirectSums.direct_sum</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">direct_sum(A::SparseMatrixCSC, B::SparseMatrixCSC)</code></pre><p>Returns the direct sum of two sparse matrices.</p></div><a class="docs-sourcelink" href="https://github.com/kestrelquantum/PiccoloQuantumObjects.jl/blob/v0.3.0/src/direct_sums.jl#L25-L29" target="_blank">source</a></section></article><h2 id="Trajectory-Initialization"><a class="docs-heading-anchor" href="#Trajectory-Initialization">Trajectory Initialization</a><a id="Trajectory-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectory-Initialization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractPiccoloOperator, Int64, Union{Real, AbstractVecOrMat{&lt;:Real}}, Vararg{Any}}" id="QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractPiccoloOperator, Int64, Union{Real, AbstractVecOrMat{&lt;:Real}}, Vararg{Any}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_trajectory</code></pre><p>Trajectory initialization of unitaries.</p></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/trajectory_initialization.jl#L384-L388" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{&lt;:AbstractVector{ComplexF64}}, AbstractVector{&lt;:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{&lt;:Real}}, Vararg{Any}}" id="QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{AbstractVector{&lt;:AbstractVector{ComplexF64}}, AbstractVector{&lt;:AbstractVector{ComplexF64}}, Int64, Union{Real, AbstractVector{&lt;:Real}}, Vararg{Any}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_trajectory</code></pre><p>Trajectory initialization of quantum states.</p></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/trajectory_initialization.jl#L446-L450" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Any, Any, Int64, Union{Real, AbstractVecOrMat{&lt;:Real}}, Vararg{Any}}" id="QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Any, Any, Int64, Union{Real, AbstractVecOrMat{&lt;:Real}}, Vararg{Any}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_trajectory</code></pre><p>Trajectory initialization of density matrices.</p></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/trajectory_initialization.jl#L511-L515" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{&lt;:AbstractMatrix{Float64}}, Vector{&lt;:AbstractVector{Float64}}, Vector{&lt;:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{&lt;:Float64}}, Int64, Tuple{Vararg{Union{Tuple{AbstractVector{R}, AbstractVector{R}}, AbstractVector{R}} where R&lt;:Real}}}" id="QuantumCollocation.TrajectoryInitialization.initialize_trajectory-Tuple{Vector{&lt;:AbstractMatrix{Float64}}, Vector{&lt;:AbstractVector{Float64}}, Vector{&lt;:AbstractVector{Float64}}, AbstractVector{Symbol}, Int64, Union{Float64, AbstractVecOrMat{&lt;:Float64}}, Int64, Tuple{Vararg{Union{Tuple{AbstractVector{R}, AbstractVector{R}}, AbstractVector{R}} where R&lt;:Real}}}"><code>QuantumCollocation.TrajectoryInitialization.initialize_trajectory</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">initialize_trajectory</code></pre><p>Initialize a trajectory for a control problem. The trajectory is initialized with data that should be consistently the same type (in this case, Float64).</p></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/trajectory_initialization.jl#L252-L259" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.TrajectoryInitialization.unitary_geodesic" id="QuantumCollocation.TrajectoryInitialization.unitary_geodesic"><code>QuantumCollocation.TrajectoryInitialization.unitary_geodesic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitary_geodesic(
    operator::EmbeddedOperator,
    samples::Int;
    kwargs...
)

unitary_geodesic(
    U_goal::AbstractMatrix{&lt;:Number},
    samples::Int;
    kwargs...
)

unitary_geodesic(
    U₀::AbstractMatrix{&lt;:Number},
    U₁::AbstractMatrix{&lt;:Number},
    samples::Number;
    kwargs...
)

unitary_geodesic(
    U₀::AbstractMatrix{&lt;:Number},
    U₁::AbstractMatrix{&lt;:Number},
    timesteps::AbstractVector{&lt;:Number};
    return_generator=false
)</code></pre><p>Compute a geodesic connecting two unitary operators.</p></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/trajectory_initialization.jl#L55-L83" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.TrajectoryInitialization.unitary_geodesic-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}" id="QuantumCollocation.TrajectoryInitialization.unitary_geodesic-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, AbstractVector{&lt;:Number}}"><code>QuantumCollocation.TrajectoryInitialization.unitary_geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitary_geodesic(U_init, U_goal, times; kwargs...)</code></pre><p>Compute the geodesic connecting U<em>init and U</em>goal at the specified times. Allows for the possibility of unequal times and ranges outside [0,1].</p><p><strong>Arguments</strong></p><ul><li><code>U_init::AbstractMatrix{&lt;:Number}</code>: The initial unitary operator.</li><li><code>U_goal::AbstractMatrix{&lt;:Number}</code>: The goal unitary operator.</li><li><code>times::AbstractVector{&lt;:Number}</code>: The times at which to evaluate the geodesic.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>return_unitary_isos::Bool=true</code>: If true returns a matrix where each column is a unitary isovec, i.e. vec(vcat(real(U), imag(U))). If false, returns a vector of unitary matrices.</li><li><code>return_generator::Bool=false</code>: If true, returns the effective Hamiltonian generating the geodesic.</li></ul></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/trajectory_initialization.jl#L126-L139" target="_blank">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" href="#QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, Int64}" id="QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation-Tuple{AbstractMatrix{&lt;:Number}, AbstractMatrix{&lt;:Number}, Int64}"><code>QuantumCollocation.TrajectoryInitialization.unitary_linear_interpolation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">unitary_linear_interpolation(
    U_init::AbstractMatrix,
    U_goal::AbstractMatrix,
    samples::Int
)</code></pre><p>Compute a linear interpolation of unitary operators with <code>samples</code> samples.</p></div><a class="docs-sourcelink" href="https://github.com/harmoniqs/QuantumCollocation.jl/blob/62faf84b2cf4dba2b6a7357926260c9775985e6b/src/trajectory_initialization.jl#L26-L34" target="_blank">source</a></section></article><h2 id="Trajectory-Interpolations"><a class="docs-heading-anchor" href="#Trajectory-Interpolations">Trajectory Interpolations</a><a id="Trajectory-Interpolations-1"></a><a class="docs-heading-anchor-permalink" href="#Trajectory-Interpolations" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../generated/man/ipopt_callbacks/">« Callbacks</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Friday 28 February 2025 08:36">Friday 28 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>